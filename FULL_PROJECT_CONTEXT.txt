================================================================================
PROJECT CONTEXT DUMP
Source: DocWorkbench
================================================================================


==================== START FILE: build_debug.ps1 ====================
# build_debug.ps1
Write-Host "üöß BUILDING DEBUG VERSION (CONSOLE ENABLED)..." -ForegroundColor Yellow

# Clean previous builds to ensure no ghost files remain
Remove-Item -Path "build", "dist" -Recurse -ErrorAction SilentlyContinue

# 1. --console: Keeps the black terminal window open so we can see errors.
# 2. --collect-all PySide6: Brute-forces every Qt file into the build (fixes missing DLLs).
# 3. --debug=all: Tells the bootloader to talk to us.

pyinstaller --noconfirm --onedir --console --clean `
    --name "DocRefine_Debug" `
    --collect-all "PySide6" `
    --hidden-import "PySide6.QtXml" `
    --hidden-import "PySide6.QtNetwork" `
    --paths "." `
    main.py

Write-Host "‚úÖ Build Complete." -ForegroundColor Green
Write-Host "üëâ Please run: .\dist\DocRefine_Debug\DocRefine_Debug.exe" -ForegroundColor Cyan
==================== END FILE: build_debug.ps1 ====================


==================== START FILE: build_release.ps1 ====================
# build_release.ps1
# ------------------------------------------------------------------------------
# DOCREFINE PRO BUILDER (v128 Spec-First Edition)
# ------------------------------------------------------------------------------
$Version = "v128"
$ErrorActionPreference = "Stop"

Write-Host "üöÄ STARTING PRODUCTION BUILD [$Version]..." -ForegroundColor Cyan

# 1. CLEANUP
Write-Host "üßπ Cleaning workspace..." -ForegroundColor Yellow
if (Test-Path "dist") { Remove-Item -Path "dist" -Recurse -Force }
if (Test-Path "build") { Remove-Item -Path "build" -Recurse -Force }

# 2. BUILD COMMAND
Write-Host "üî® Compiling binary using Spec file..." -ForegroundColor Yellow

# v128 Update: Removed CLI overrides (--collect-all). 
# We now rely 100% on DocRefinePro.spec for inclusion/exclusion logic.
python -m PyInstaller DocRefinePro.spec --noconfirm --clean

# 3. VERIFICATION
$BinPath = "dist/DocRefinePro/DocRefinePro.exe"

if (Test-Path $BinPath) {
    Write-Host "‚úÖ BUILD SUCCESSFUL!" -ForegroundColor Green
    Write-Host "üì¶ Output: $BinPath" -ForegroundColor White
}

if (-not (Test-Path $BinPath)) {
    Write-Host "‚ùå BUILD FAILED." -ForegroundColor Red
}
==================== END FILE: build_release.ps1 ====================


==================== START FILE: CHANGELOG.md ====================
# DocRefine Pro - Changelog

## [v128.4] - 2026-01-16
### Architecture & Optimization
* **Spec-First Build System:** Migrated from CLI overrides to a pure Python Spec file architecture for consistent cross-platform building.
* **Mac Diet (Surgical):** Reduced macOS app bundle size from **1.3GB to ~200MB** via:
    * **Pre-Build:** Filtering `hiddenimports` to prevent PyInstaller hooks from loading unwanted Qt frameworks (WebEngine, Quick, 3D).
    * **Post-Build:** "Nuclear" stripping script that physically removes any surviving bloat frameworks and cleans up broken symlinks to prevent installer crashes.
* **Stability:** Fixed Windows build crash caused by tuple unpacking errors in the Spec file.
* **Maintenance:** Added `tools/inventory.py` for project auditing.

## [v128] - 2026-01-16
### Architecture
* **Build System Overhaul:** Switched to a "Spec-First" build architecture.
* **Mac Diet:** Implemented aggressive binary filtering at the PyInstaller Spec level to block `QtWebEngine`, `QtQuick`, and `Qt3D` *before* bundling. This targets the 1.3GB bloat issue directly.
* **Inventory Control:** Added `tools/inventory.py` for project auditing.
* **Cleanup:** Removed deprecated CLI overrides from build scripts.

## [v127] - 2026-01-15
### Fixed
- **Mac Build:** Resolved `OSError` in stripping script by handling symlinks correctly.
- **Optimization:** Refined `strip_mac.py` to differentiate between directories (`rmtree`) and symbolic links (`unlink`) during framework cleanup.

## [v126] - 2026-01-15
### Infrastructure
- **Mac Optimization:** Implemented `strip_mac.py` to programmatically remove unused Qt Frameworks (`QtQuick`, `QtQml`, `QtWebEngine`) post-build.
- **CI/CD:** Replaced fragile bash commands with Python scripting for reliable path resolution during the build process.
- **Size Reduction:** Forced removal of PyInstaller-protected frameworks to reduce DMG size from ~1.2GB to target (~400MB).

## [v125] - 2026-01-15
### Infrastructure
- **Mac Optimization:** Implemented manual framework stripping in CI/CD to reduce DMG size.
- **Cleanup:** Removed unused Qt translations and debug symbols from the macOS binary.

## [v124] - 2026-01-15
### Fixed
- **Build Fix**: Resolved `TypeError` in Spec file caused by deprecated `include_pycache` argument in PyInstaller 6.18.

## [v123] - 2026-01-15
### Infrastructure
- **Size Optimization:** Reduced DMG/EXE footprint by ~50% via targeted PySide6 stripping.
- **Compression:** Integrated UPX compression and enabled binary symbol stripping.
- **Architecture:** Moved from `collect_all` to manual dependency mapping to prevent "Universal" binary bloat.

## [v122] - 2026-01-15
### Infrastructure
- **Build Fix:** Added `BUNDLE` block to Spec file for correct macOS `.app` generation.
- **Asset Safety:** Added fallback logic for missing application icons during build.

## [v121] - 2026-01-15
### Maintenance
- **Release:** Fixed Git tag synchronization for CI/CD pipeline.

## [v120] - 2026-01-15
### Infrastructure
- **Spec-Based Build:** Switched from CLI commands to `DocRefinePro.spec` for release builds.
- **Cross-Platform Fix:** Added `collect_all('PySide6')` to the build spec to ensure Mac/Win DLLs are bundled correctly.

## v119 (The Great Refactor)
* [Architecture] **UI Migration:** Complete rewrite of the UI layer from Tkinter to **PySide6 (Qt)**.
    * Modern "Fusion" theme with Dark Mode support.
    * Non-blocking, thread-safe architecture using Signals & Slots.
* [New] **Forensic Comparator 2.0:**
    * Synchronized Zoom & Pan.
    * Dark background for high-contrast inspection.
    * Smooth page scrolling.
* [New] **Active Worker Visualizer:** Real-time grid showing multi-threaded status.
* [Improved] **Timer Logic:** Job timer now respects "Pause" state.
* [Fixed] **Windows Explorer:** Fixed "Reveal in Folder" failing due to subprocess restrictions.

## v118-patch1
* [Fixed] **Context Menu Bug:** Fixed "Reveal in Folder" failure by using unique ID lookup instead of fragile filename matching.

## v118 (Modular Foundation)
* [Architecture] **Modular Restructure:** Application logic split into `gui`, `worker`, `processing`, and `config` modules for improved stability.
* [Improvement] **Update Signal:** Hardcoded verification of v118.
* [Docs] Updated bundled documentation paths.

## v117 (Hotfixes)
* [Fixed] **Ingest Crash:** Resolved regression in `run_inventory` arguments.
* [Fixed] **Debug Export:** Fixed threading violation in export tool.
* [Refactor] **Thread Safety:** Hardened UI/Worker separation.

## v116
* [Added] In-App Documentation Viewer.
* [Improved] Intelligent Resource Loader.

## v115
* [Fixed] Mac UI freeze (queue throttling).
* [Fixed] Windows "Ghost Windows" patch.
==================== END FILE: CHANGELOG.md ====================


==================== START FILE: deploy.ps1 ====================
# SAVE AS: deploy.ps1 in your Project Root
param (
    [Parameter(Mandatory=$true)]
    [string]$Version
)

# --- CONFIGURATION ---
$DriveLink = "https://drive.google.com/drive/folders/1_9IoOZK5dW6rsjUp5eq-3vT8LIOlKYkU?usp=sharing"
$GistFolder = ".\53752cda3c39550673fc5dafb96c4bed" # Folder name matches Gist ID
$JsonFile = "$GistFolder\docrefine_version.json"

# --- SAFETY CHECKS ---
if (-not (Test-Path $GistFolder)) {
    Write-Error "CRITICAL: Gist submodule folder not found at $GistFolder"
    exit
}

Write-Host "=== DOCREFINE PRO DEPLOYMENT PROTOCOL ===" -ForegroundColor Cyan
Write-Host "Target Version: $Version" -ForegroundColor Yellow
Write-Host "Channel: Permanent Drive Folder" -ForegroundColor Yellow

# 1. UPDATE GIST JSON
Write-Host "`n[1/4] Updating Update Signal (Gist)..." -ForegroundColor Green
$JsonContent = @{
    latest_version = $Version
    download_url = $DriveLink
} | ConvertTo-Json -Depth 2

$JsonContent | Set-Content -Path $JsonFile
Write-Host "JSON Updated locally."

# 2. PUSH GIST
Write-Host "`n[2/4] Publishing Signal to Cloud..." -ForegroundColor Green
Push-Location $GistFolder
git add docrefine_version.json
git commit -m "Update signal to $Version"
git push
if ($LASTEXITCODE -ne 0) { Write-Error "Failed to push Gist."; Pop-Location; exit }
Pop-Location

# 3. TAG & PUSH MAIN REPO
Write-Host "`n[3/4] Triggering Build Pipeline..." -ForegroundColor Green
git add .
git commit -m "Release $Version"
git tag $Version
git push origin main --tags
if ($LASTEXITCODE -ne 0) { Write-Error "Failed to push Repo."; exit }

# 4. INSTRUCTIONS
Write-Host "`n[4/4] DEPLOYMENT SEQUENCED." -ForegroundColor Cyan
Write-Host "---------------------------------------------------"
Write-Host "1. GitHub Actions is now building $Version."
Write-Host "2. Wait for the build to finish."
Write-Host "3. Download the artifacts (Win .exe / Mac .app)."
Write-Host "4. DRAG AND DROP them into this Drive Folder:"
Write-Host "   $DriveLink"
Write-Host "---------------------------------------------------"
Pause
==================== END FILE: deploy.ps1 ====================


==================== START FILE: DocRefinePro.spec ====================
# -*- mode: python ; coding: utf-8 -*-
import sys
import os
from PyInstaller.utils.hooks import collect_all

# ... (Standard headers)

# 1. Collect PySide6
pyside_datas, pyside_binaries, pyside_hidden = collect_all('PySide6')

# 2. Define Exclusion List
EXCLUSION_PATTERNS = [
    'PySide6.QtWebEngine', 'PySide6.QtWebEngineCore', 'PySide6.QtWebEngineWidgets', 'PySide6.QtWebEngineQuick',
    'QtWebEngine', 'QtWebEngineCore', 'QtWebEngineWidgets', 'QtWebEngineQuick',
    'PySide6.QtQuick', 'PySide6.QtQuickWidgets', 'PySide6.QtQuick3D', 'PySide6.QtQuickControls2',
    'QtQuick', 'QtQuickWidgets', 'QtQuick3D', 'QtQuickControls2',
    'PySide6.QtQml', 'PySide6.QtQml.WorkerScript', 'QtQml',
    'PySide6.Qt3DCore', 'PySide6.Qt3DInput', 'PySide6.Qt3DLogic', 'PySide6.Qt3DRender', 'PySide6.Qt3DAnimation', 'PySide6.Qt3DExtras',
    'Qt3DCore', 'Qt3DInput', 'Qt3DLogic', 'Qt3DRender', 'Qt3DAnimation', 'Qt3DExtras',
    'PySide6.QtVirtualKeyboard', 'QtVirtualKeyboard',
    'PySide6.QtSerialBus', 'PySide6.QtSerialPort', 'QtSerialBus', 'QtSerialPort',
    'PySide6.QtSensors', 'QtSensors',
    'PySide6.QtCharts', 'QtCharts',
    'PySide6.QtDataVisualization', 'QtDataVisualization',
    'PySide6.QtTest', 'QtTest',
    'PySide6.QtTextToSpeech', 'QtTextToSpeech',
    'PySide6.QtDesigner', 'QtDesigner',
    'PySide6.QtHelp', 'QtHelp',
    'PySide6.QtMultimedia', 'PySide6.QtMultimediaWidgets', 'QtMultimedia', 'QtMultimediaWidgets',
    'PySide6.QtLocation', 'QtLocation',
    'PySide6.QtPositioning', 'QtPositioning',
    'PySide6.QtNetworkAuth', 'QtNetworkAuth',
    'PySide6.QtScxml', 'QtScxml',
    'PySide6.QtRemoteObjects', 'QtRemoteObjects',
    'PySide6.QtStateMachine', 'QtStateMachine',
    'opengl32sw', 'd3dcompiler'
]

# 3. Filter Binaries (CRASH FIX: Handle tuple sizes safely)
filtered_binaries = []
for binary in pyside_binaries:
    is_bad = False
    for item in binary:
        if isinstance(item, str) and any(bad in item for bad in EXCLUSION_PATTERNS):
            is_bad = True
            break
    if not is_bad:
        filtered_binaries.append(binary)

# 4. Filter Hidden Imports
filtered_hidden_imports = [
    h for h in pyside_hidden 
    if not any(bad in h for bad in EXCLUSION_PATTERNS)
]

block_cipher = None
target_icon = 'resources/app_icon.ico'
if not os.path.exists(target_icon): target_icon = None

a = Analysis(
    ['main.py'],
    pathex=[],
    binaries=filtered_binaries, 
    datas=pyside_datas,
    hiddenimports=[
        'docrefine.gui.app_qt', 
        'docrefine.processing', 
        'docrefine.worker'
    ] + filtered_hidden_imports, 
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=EXCLUSION_PATTERNS,
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='DocRefinePro',
    debug=False,
    bootloader_ignore_signals=False,
    strip=True,
    upx=True,
    console=False,
    icon=target_icon,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=True,
    upx=True,
    name='DocRefinePro',
)

if sys.platform == 'darwin':
    app = BUNDLE(
        coll,
        name='DocRefinePro.app',
        icon=None,
        bundle_identifier='com.docrefine.pro',
    )
==================== END FILE: DocRefinePro.spec ====================


==================== START FILE: DocRefine_Debug.spec ====================
# -*- mode: python ; coding: utf-8 -*-
from PyInstaller.utils.hooks import collect_all

datas = []
binaries = []
hiddenimports = ['PySide6.QtXml', 'PySide6.QtNetwork']
tmp_ret = collect_all('PySide6')
datas += tmp_ret[0]; binaries += tmp_ret[1]; hiddenimports += tmp_ret[2]


a = Analysis(
    ['main.py'],
    pathex=['.'],
    binaries=binaries,
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='DocRefine_Debug',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=True,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)
coll = COLLECT(
    exe,
    a.binaries,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='DocRefine_Debug',
)

==================== END FILE: DocRefine_Debug.spec ====================


==================== START FILE: FULL_PROJECT_CONTEXT.txt ====================

==================== END FILE: FULL_PROJECT_CONTEXT.txt ====================


==================== START FILE: main.py ====================
import sys
from docrefine.config import log_app

if __name__ == "__main__":
    try:
        log_app("Booting DocRefine Pro (Qt/PySide6 Edition)...")
        # Import the new Qt App Runner
        from docrefine.gui.app_qt import run
        run()
    except Exception as e:
        print(f"Fatal Boot Error: {e}")
==================== END FILE: main.py ====================


==================== START FILE: README.md ====================
# DocRefine Pro v119

**Enterprise-Grade Document Processing & Organization Tool**

**DocRefine Pro** is a standalone desktop application for batch processing document workflows (Ingestion, Deduplication, Flattening, OCR). It runs 100% locally on your machine‚Äîno cloud uploads.

**v119 Update (The Great Refactor):**
* **New Engine:** Migrated to PySide6 (Qt) for improved stability and Dark Mode support.
* **Forensic Viewer 2.0:** Side-by-side comparison with synchronized zoom and panning.
* **Multi-Threading:** Real-time visualization of active worker threads.
* **Controls:** Pause/Resume support for long-running batch jobs.

---

## üì• Installation Instructions

### ü™ü Windows
1.  Download `DocRefinePro_Win_v119.zip`.
2.  Right-click the zip file -> **Extract All**.
3.  Open the extracted folder.
4.  Double-click **DocRefine Pro.exe**.
    * *Note: If Windows SmartScreen appears, click "More Info" -> "Run Anyway".*

### üçé macOS
1.  Download `DocRefinePro_Mac_v119.dmg`.
2.  Double-click the `.dmg` file to mount it.
3.  **Drag the DocRefine Pro app** into your **Applications** folder.
    * *Note: The application size is larger (~230MB) due to the inclusion of the complete Qt6 Framework for native performance.*

#### ‚ö†Ô∏è Critical: "App is Damaged" Fix
Because this is an internal tool not signed by the Apple Store, macOS will likely block it with a message saying *"The app is damaged"* or *"Cannot be opened."*

**To fix this (One-time setup):**
1.  Open your Mac's **Terminal** app (Command+Space, type "Terminal").
2.  Paste the following command and hit Enter:
    ```bash
    xattr -cr /Applications/DocRefinePro.app
    ```
3.  You can now open the app normally from your Applications folder.

---

## üöÄ Quick Start Guide

### 1. Ingest
* Click **+ New Ingest Job**.
* Select your source folder containing raw documents.
* **Standard Mode:** Best for most PDFs.
* **Lightning Mode:** Fastest (Exact duplicate detection only).

### 2. Process
* **Refine Tab:** Flatten, OCR, or Sanitize files.
* **Pause/Resume:** You can now pause processing to free up system resources without cancelling the job.
* **Forensic Viewer:** Go to the Inspector tab, right-click a duplicate, and select "Compare Duplicates" to visually verify files.

### 3. Output
* **Option A (Unique Masters):** Export a clean folder containing one copy of every unique file.
* **Option B (Reconstruction):** Re-create the original folder structure using the optimized master files.

### 4. Support
For bugs or feature requests, contact the development team directly (Jason Diaz - Task Specialist : jason@weblifestores.com).

==================== END FILE: README.md ====================


==================== START FILE: requirements.txt ====================
pillow
pytesseract
pdf2image
pypdf
psutil
pyinstaller
PySide6
==================== END FILE: requirements.txt ====================


==================== START FILE: strip_mac.py ====================
import os
import shutil
from pathlib import Path

# The Target: Your built macOS App Bundle
APP_PATH = Path("dist/DocRefinePro.app")
FRAMEWORKS_DIR = APP_PATH / "Contents" / "Frameworks"
PLUGINS_DIR = APP_PATH / "Contents" / "Resources" / "PySide6" / "plugins"

# The Hit List: Modules verified in logs as BLOAT
BLOAT_PATTERNS = [
    "QtWebEngine", "QtQuick", "QtQml", "Qt3D", 
    "QtVirtualKeyboard", "QtSerialBus", "QtSerialPort",
    "QtSensors", "QtCharts", "QtDataVisualization",
    "QtTest", "QtTextToSpeech", "QtDesigner", "QtHelp",
    "QtMultimedia", "QtLocation", "QtPositioning",
    "QtNetworkAuth", "QtScxml", "QtRemoteObjects",
    "QtStateMachine", "QtXml", "QtSql"
]

def get_size(path):
    total = 0
    if not path.exists(): return 0
    if path.is_file(): return path.stat().st_size
    for entry in os.scandir(path):
        if entry.is_file(): total += entry.stat().st_size
        elif entry.is_dir(): total += get_size(Path(entry.path))
    return total

def nuke_path(path):
    if not path.exists() and not path.is_symlink(): return 0
    deleted = 0
    try:
        # If it's a directory, get size and remove tree
        if path.is_dir() and not path.is_symlink():
            deleted += get_size(path)
            shutil.rmtree(path)
        # If it's a file or symlink, just unlink
        else:
            if not path.is_symlink():
                deleted += path.stat().st_size
            path.unlink()
    except Exception as e:
        print(f"Error nuking {path}: {e}")
    return deleted

def cleanup_broken_symlinks():
    print("üßπ SCANNING FOR BROKEN SYMLINKS...")
    broken_count = 0
    for root, dirs, files in os.walk(APP_PATH):
        for filename in files:
            p = Path(root) / filename
            if p.is_symlink():
                if not p.exists(): # Checks if target exists
                    print(f"   ‚úÇÔ∏è Removing broken link: {p.name}")
                    p.unlink()
                    broken_count += 1
    print(f"   Fixed {broken_count} broken links.")

def nuke_bloat():
    print(f"üöÄ STARTING SURGICAL REMOVAL ON: {APP_PATH}")
    if not APP_PATH.exists():
        print(f"‚ùå CRITICAL: App bundle not found at {APP_PATH}"); return

    deleted_size = 0

    # 1. SCAN FRAMEWORKS
    if FRAMEWORKS_DIR.exists():
        for item in FRAMEWORKS_DIR.iterdir():
            if any(pattern in item.name for pattern in BLOAT_PATTERNS):
                print(f"   üí£ NUKE FRAMEWORK: {item.name}")
                deleted_size += nuke_path(item)

    # 2. SCAN PLUGINS
    if PLUGINS_DIR.exists():
        for root, dirs, files in os.walk(PLUGINS_DIR):
            for d in dirs[:]: 
                if any(pattern in d for pattern in BLOAT_PATTERNS):
                    full_path = Path(root) / d
                    print(f"   üí£ NUKE PLUGIN: {d}")
                    deleted_size += nuke_path(full_path)
                    dirs.remove(d)
                    
    # 3. GARBAGE COLLECTION (Crucial Step)
    cleanup_broken_symlinks()

    print("-" * 60)
    print(f"‚úÖ CLEANUP COMPLETE. REMOVED: {deleted_size / 1024 / 1024:.2f} MB")
    print("-" * 60)

if __name__ == "__main__":
    nuke_bloat()
==================== END FILE: strip_mac.py ====================


==================== START FILE: .github\workflows\build.yml ====================
name: Build DocRefine Pro (Multi-OS)

permissions:
  contents: write

on:
  push:
    tags:
      - 'v*'

jobs:
  # ====================================================
  # JOB 1: WINDOWS BUILD (Stable at ~250MB)
  # ====================================================
  build-windows:
    name: Windows Build
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10' 

    - name: Install UPX (Windows)
      run: choco install upx

    - name: Install Libraries
      run: |
        python -m pip install --upgrade pip
        pip install psutil Pillow pytesseract pdf2image pypdf pyinstaller PySide6

    # v128 Update: Spec-First Build (CLI overrides removed)
    - name: Build with PyInstaller
      run: |
        pyinstaller DocRefinePro.spec --noconfirm --clean

    - name: Bundle Readme & Changelog
      run: |
        copy README.md dist/DocRefinePro/
        copy CHANGELOG.md dist/DocRefinePro/
        copy LICENSE dist/DocRefinePro/

    - name: Zip the Build
      run: |
        powershell Compress-Archive -Path dist/DocRefinePro -DestinationPath DocRefinePro_Win_${{ github.ref_name }}.zip

    - name: Release Windows Artifact
      uses: softprops/action-gh-release@v1
      if: startsWith(github.ref, 'refs/tags/')
      with:
        files: DocRefinePro_Win_${{ github.ref_name }}.zip

  # ====================================================
  # JOB 2: MAC BUILD (Surgical Stripping v128.4)
  # ====================================================
  build-mac:
    name: macOS Build
    runs-on: macos-latest
    
    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install Mac System Deps
      run: |
        brew update
        brew install poppler tesseract tesseract-lang create-dmg upx

    - name: Install Python Libs
      run: |
        python -m pip install --upgrade pip
        pip install psutil Pillow pytesseract pdf2image pypdf pyinstaller PySide6

    # v128 Update: Spec-First Build (CLI overrides removed)
    - name: Build Mac App
      run: |
        pyinstaller DocRefinePro.spec --noconfirm --clean

    # v128.4 Update: The "Nuclear" Strip + Garbage Collection
    # 1. Runs our python script to delete heavy frameworks and clean broken symlinks
    # 2. Runs native 'strip' on binary symbols for whatever is left
    - name: Post-Build Manual Stripping (v128.4)
      run: |
        echo "Running surgical strip script..."
        python strip_mac.py
        
        echo "Stripping remaining binary symbols..."
        find dist/DocRefinePro.app -name "*.dylib" -exec strip -x {} \;
        strip "dist/DocRefinePro.app/Contents/MacOS/DocRefinePro"

    - name: Create DMG Installer
      run: |
        mkdir -p dist/dmg_content
        # Use -a to preserve structure and symlinks safely (CRITICAL FIX)
        cp -a "dist/DocRefinePro.app" dist/dmg_content
        cp README.md dist/dmg_content/
        cp CHANGELOG.md dist/dmg_content/
        cp LICENSE dist/dmg_content/

        create-dmg \
          --volname "DocRefinePro Installer" \
          --window-pos 200 120 \
          --window-size 800 500 \
          --icon-size 100 \
          --icon "DocRefinePro.app" 200 190 \
          --hide-extension "DocRefinePro.app" \
          --app-drop-link 600 185 \
          --icon "README.md" 200 350 \
          --icon "CHANGELOG.md" 400 350 \
          --icon "LICENSE" 600 350 \
          "dist/DocRefinePro_Mac_${{ github.ref_name }}.dmg" \
          "dist/dmg_content"

    - name: Release Mac Artifact
      uses: softprops/action-gh-release@v1
      if: startsWith(github.ref, 'refs/tags/')
      with:
        files: dist/DocRefinePro_Mac_${{ github.ref_name }}.dmg
==================== END FILE: .github\workflows\build.yml ====================


==================== START FILE: 53752cda3c39550673fc5dafb96c4bed\docrefine_version.json ====================
{
    "download_url":  "https://drive.google.com/drive/folders/1_9IoOZK5dW6rsjUp5eq-3vT8LIOlKYkU?usp=sharing",
    "latest_version":  "v128.4"
}

==================== END FILE: 53752cda3c39550673fc5dafb96c4bed\docrefine_version.json ====================


==================== START FILE: docrefine\config.py ====================
import sys
import os
import subprocess
import json
import logging
import platform
import shutil
import time
from pathlib import Path
from logging.handlers import RotatingFileHandler
from datetime import datetime

# ==============================================================================
#   WINDOWS GHOST WINDOW FIX (Global Patch)
# ==============================================================================
if os.name == 'nt':
    try:
        _original_popen = subprocess.Popen
        def safe_popen(*args, **kwargs):
            if 'startupinfo' not in kwargs:
                si = subprocess.STARTUPINFO()
                si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                si.wShowWindow = subprocess.SW_HIDE
                kwargs['startupinfo'] = si
                if 'creationflags' not in kwargs:
                    kwargs['creationflags'] = 0x08000000 
            return _original_popen(*args, **kwargs)
        subprocess.Popen = safe_popen
    except Exception as e: print(f"Warning: Could not patch subprocess: {e}")

# ==============================================================================
#   SYSTEM UTILITIES
# ==============================================================================
class SystemUtils:
    IS_WIN = platform.system() == 'Windows'
    IS_MAC = platform.system() == 'Darwin'
    CURRENT_VERSION = "v128.4"
    UPDATE_MANIFEST_URL = "https://gist.githubusercontent.com/jasonweblifestores/53752cda3c39550673fc5dafb96c4bed/raw/docrefine_version.json"

    @staticmethod
    def get_resource_dir():
        if getattr(sys, 'frozen', False): return Path(sys._MEIPASS)
        return Path(__file__).parent.parent # Adjusted for package structure

    @staticmethod
    def get_user_data_dir():
        if SystemUtils.IS_MAC or SystemUtils.IS_WIN:
            p = Path.home() / "Documents" / "DocRefinePro_Data"
            p.mkdir(parents=True, exist_ok=True)
            return p
        if getattr(sys, 'frozen', False): return Path(sys.executable).parent
        return Path(__file__).parent.parent

    @staticmethod
    def find_doc_file(filename):
        # 1. Look in bundled resources (PyInstaller)
        res = SystemUtils.get_resource_dir() / filename
        if res.exists(): return res
        
        # 2. Look next to executable (Portable/Distribution)
        if getattr(sys, 'frozen', False):
            exe_path = Path(sys.executable).parent / filename
            if exe_path.exists(): return exe_path
        
        # 3. Look in Project Root (Dev Mode - One level up from this file)
        cwd = Path(__file__).parent.parent / filename
        if cwd.exists(): return cwd
        
        return None

    @staticmethod
    def open_file(path):
        p = str(path)
        try:
            if not Path(p).exists(): return
            if SystemUtils.IS_WIN: os.startfile(p)
            elif SystemUtils.IS_MAC: subprocess.call(['open', p])
            else: subprocess.call(['xdg-open', p])
        except Exception as e: print(f"Error opening file: {e}")

    @staticmethod
    def reveal_file(path):
        p = str(Path(path).resolve())
        try:
            if not Path(p).exists(): return
            if SystemUtils.IS_WIN:
                subprocess.Popen(f'explorer /select,"{p}"')
            elif SystemUtils.IS_MAC:
                subprocess.Popen(["open", "-R", p])
            else:
                subprocess.call(['xdg-open', str(Path(p).parent)])
        except Exception as e:
            print(f"Error revealing file: {e}")
            SystemUtils.open_file(Path(p).parent)

    @staticmethod
    def find_binary(bin_name):
        res_dir = SystemUtils.get_resource_dir()
        if (res_dir / bin_name).exists(): return str(res_dir / bin_name)
        if (res_dir / "bin" / bin_name).exists(): return str(res_dir / "bin" / bin_name)
        
        portable_target = res_dir / "DocRefine_Portable"
        if portable_target.exists():
             if (portable_target / bin_name).exists(): return str(portable_target)
             if (portable_target / "bin" / bin_name).exists(): return str(portable_target / "bin")

        sys_path = shutil.which(bin_name)
        if sys_path: return str(Path(sys_path).resolve())

        if SystemUtils.IS_MAC:
            for loc in ["/opt/homebrew/bin", "/usr/local/bin"]:
                brew_path = Path(loc) / bin_name
                if brew_path.exists(): return str(brew_path)
        return None

# ==============================================================================
#   CONFIGURATION
# ==============================================================================
class Config:
    GITHUB_REPO = "jasonweblifestores/DocRefinePro" 
    DEFAULTS = { 
        "ram_warning_mb": 1024, 
        "resize_width": 1920, 
        "log_level": "INFO",
        "max_pixels": 500000000,
        "max_threads": 0, 
        "default_export_prio": "Auto (Best Available)",
        "default_ingest_mode": "Standard", 
        "ocr_lang": "eng",
        "last_workspace": "",
        "last_geometry": "1024x700",
        "last_tab": 0
    }
    
    def __init__(self):
        self.data = self.DEFAULTS.copy()
        self.path = SystemUtils.get_user_data_dir() / "config.json"
        if self.path.exists():
            try:
                with open(self.path, 'r') as f: self.data.update(json.load(f))
            except: pass

    def get(self, key): return self.data.get(key, self.DEFAULTS.get(key))
    def set(self, key, val): self.data[key] = val; self.save()
    def reset(self): self.data = self.DEFAULTS.copy(); self.save()
    def save(self):
        try:
            with open(self.path, 'w') as f: json.dump(self.data, f, indent=4)
        except Exception as e: print(f"Config Save Error: {e}")

# Global Config Instance
CFG = Config()

# ==============================================================================
#   LOGGING
# ==============================================================================
USER_DIR = SystemUtils.get_user_data_dir()
LOG_PATH = USER_DIR / "app_debug.log"
JSON_LOG_PATH = USER_DIR / "app_events.jsonl"
WORKSPACES_ROOT = USER_DIR / "Workspaces"
WORKSPACES_ROOT.mkdir(parents=True, exist_ok=True)

logger = logging.getLogger("DocRefine")
logger.setLevel(getattr(logging, CFG.get("log_level").upper(), logging.INFO))
c_handler = logging.StreamHandler()
c_handler.setFormatter(logging.Formatter('[%(levelname)s] %(message)s'))
logger.addHandler(c_handler)

try:
    f_handler = RotatingFileHandler(LOG_PATH, maxBytes=1024*1024, backupCount=5, encoding='utf-8')
    f_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    logger.addHandler(f_handler)
except: pass

def log_app(msg, level="INFO", structured_data=None):
    if level == "ERROR": logger.error(msg)
    elif level == "WARN": logger.warning(msg)
    else: logger.info(msg)
    try:
        entry = {
            "timestamp": datetime.now().isoformat(),
            "level": level,
            "message": msg,
            "os": platform.system(),
            "version": SystemUtils.CURRENT_VERSION
        }
        if structured_data: entry.update(structured_data)
        with open(JSON_LOG_PATH, "a", encoding="utf-8") as f:
            f.write(json.dumps(entry) + "\n")
    except: pass
==================== END FILE: docrefine\config.py ====================


==================== START FILE: docrefine\processing.py ====================
import sys
import shutil
import gc
import os
import zipfile
import re
import time
from pathlib import Path
from PIL import Image, ImageFile

# Configure Pillow limits
Image.MAX_IMAGE_PIXELS = 500000000
ImageFile.LOAD_TRUNCATED_IMAGES = True

# Dependency Checks
try:
    from pdf2image import convert_from_path, pdfinfo_from_path
    import pypdf
    import pytesseract
except ImportError:
    pass

from .config import CFG, SystemUtils, log_app

# ==============================================================================
#   BINARY DETECTION
# ==============================================================================
bin_ext = ".exe" if SystemUtils.IS_WIN else ""
poppler_bin_file = SystemUtils.find_binary("pdfinfo" + bin_ext)
POPPLER_BIN = str(Path(poppler_bin_file).parent) if poppler_bin_file else None

tesseract_bin_file = SystemUtils.find_binary("tesseract" + bin_ext)
HAS_TESSERACT = bool(tesseract_bin_file)

if HAS_TESSERACT:
    pytesseract.pytesseract.tesseract_cmd = tesseract_bin_file
    if getattr(sys, 'frozen', False) and SystemUtils.IS_MAC:
        tessdata_path = SystemUtils.get_resource_dir() / "tessdata"
        if tessdata_path.exists():
            os.environ["TESSDATA_PREFIX"] = str(tessdata_path)

def parse_lang_code(selection):
    if "(" in selection and ")" in selection:
        return selection.split("(")[1].replace(")", "")
    return selection

# ==============================================================================
#   PROCESSORS
# ==============================================================================
class BaseProcessor:
    def __init__(self, p_func, s_check, p_event): 
        self.progress = p_func; self.stop_sig_func = s_check; self.pause_event = p_event 
    def check_state(self):
        if self.stop_sig_func(): raise Exception("Stopped")
        if not self.pause_event.is_set():
            self.progress(None, "Paused...", status_only=True)
            self.pause_event.wait() 
            if self.stop_sig_func(): raise Exception("Stopped")

class PdfProcessor(BaseProcessor):
    def flatten_or_ocr(self, src, dest, mode='flatten', dpi=300):
        temp = dest.parent / f"temp_{src.stem}"; temp.mkdir(parents=True, exist_ok=True)
        try:
            info = pdfinfo_from_path(str(src), poppler_path=POPPLER_BIN)
            pages = info.get("Pages", 1)
            imgs = []
            
            ocr_lang = parse_lang_code(CFG.get("ocr_lang"))

            for i in range(1, pages + 1):
                self.check_state() 
                
                # UPDATE: Report EVERY page. 
                # The worker.py throttler will ensure the UI doesn't freeze.
                self.progress((i/pages)*100, f"Page {i}/{pages}")
                
                gc.collect() 
                res = convert_from_path(str(src), dpi=dpi, first_page=i, last_page=i, poppler_path=POPPLER_BIN)
                if not res: continue
                img = res[0]
                if mode == 'ocr' and HAS_TESSERACT:
                    t_page = temp / f"page_{i}.jpg"; img.save(t_page, "JPEG", dpi=(int(dpi), int(dpi)))
                    f = temp / f"{i}.pdf"
                    with open(f, "wb") as o: o.write(pytesseract.image_to_pdf_or_hocr(str(t_page), extension='pdf', lang=ocr_lang))
                    imgs.append(str(f))
                else:
                    f = temp / f"{i}.jpg"; img.convert('RGB').save(f, "JPEG", quality=85); imgs.append(str(f))
                del res; del img
            
            self.check_state(); self.progress(100, "Merging...")
            
            if mode == 'ocr' and HAS_TESSERACT:
                m = pypdf.PdfWriter(); 
                for f in imgs: m.append(f)
                m.write(dest); m.close()
            else:
                base = Image.open(imgs[0]).convert('RGB')
                base.save(dest, "PDF", resolution=float(dpi), save_all=True, append_images=[Image.open(f).convert('RGB') for f in imgs[1:]])
            return True
        except Exception as e: 
            if str(e) == "Stopped": raise
            return False
        finally: shutil.rmtree(temp, ignore_errors=True); gc.collect()

class ImageProcessor(BaseProcessor):
    def resize(self, src, dest, w):
        try:
            self.check_state(); self.progress(50, "Processing...")
            with Image.open(src) as img:
                img.load(); r = min(w / img.width, 1.0)
                img.resize((int(img.width * r), int(img.height * r)), Image.Resampling.LANCZOS).convert('RGB').save(dest, "JPEG", quality=85)
            return True
        except Exception as e:
            if str(e) == "Stopped": raise
            return False
    def convert_to_pdf(self, src, dest):
        try:
            self.check_state(); self.progress(50, "Converting...")
            with Image.open(src) as img: img.load(); img.convert('RGB').save(dest, "PDF")
            return True
        except Exception as e:
            if str(e) == "Stopped": raise
            return False

class OfficeProcessor(BaseProcessor):
    def sanitize(self, src, dest):
        try:
            self.check_state()
            if src.suffix.lower() not in {'.docx', '.xlsx'}: shutil.copy2(src, dest); return False
            if not zipfile.is_zipfile(src): raise Exception("Corrupt File")
            self.progress(50, "Sanitizing...")
            t = dest.parent / f"temp_{src.stem}"; shutil.rmtree(t, ignore_errors=True)
            with zipfile.ZipFile(src) as z: z.extractall(t)
            c = t / "docProps" / "core.xml"
            if c.exists(): c.write_text(re.sub(r'(<dc:creator>).*?(</dc:creator>)', r'\1\2', c.read_text(), flags=re.DOTALL))
            with zipfile.ZipFile(dest, 'w') as z:
                for r, _, fs in os.walk(t):
                    for f in fs: z.write(Path(r)/f, (Path(r)/f).relative_to(t))
            shutil.rmtree(t)
            return True
        except Exception as e:
            if str(e) == "Stopped": raise
            shutil.copy2(src, dest); return False
==================== END FILE: docrefine\processing.py ====================


==================== START FILE: docrefine\worker.py ====================
# SAVE AS: docrefine/worker.py
import threading
import time
import json
import shutil
import hashlib
import uuid
import os
import csv
import re
import concurrent.futures
import platform
from pathlib import Path
from datetime import datetime, timedelta

# Local Package Imports
from .config import CFG, SystemUtils, log_app, WORKSPACES_ROOT, LOG_PATH, JSON_LOG_PATH
from .core.events import AppEvent, EventType
from .processing import (
    PdfProcessor, 
    ImageProcessor, 
    OfficeProcessor, 
    POPPLER_BIN, 
    HAS_TESSERACT,
    pdfinfo_from_path,
    convert_from_path
)

# 3rd Party Dependencies
try:
    import psutil
    HAS_PSUTIL = True
except ImportError:
    HAS_PSUTIL = False

try:
    from pypdf import PdfReader
except ImportError:
    PdfReader = None

SUPPORTED_EXTENSIONS = {'.pdf', '.doc', '.docx', '.jpg', '.png', '.xls', '.xlsx', '.csv', '.jpeg'}

# ==============================================================================
#   HELPER FUNCTIONS (Preserved from v118)
# ==============================================================================

def sanitize_filename(name):
    return re.sub(r'[<>:"/\\|?*]', '_', name)

def update_stats_time(ws, cat, sec):
    try:
        p = Path(ws) / "stats.json"
        if not p.exists(): return
        with open(p, 'r') as f: s = json.load(f)
        s[cat] = s.get(cat, 0.0) + sec
        with open(p, 'w') as f: json.dump(s, f, indent=4)
    except: pass

def generate_job_report(ws_path, action_name, file_results=None):
    # Logic identical to v118, preserved for report generation
    try:
        ws = Path(ws_path)
        rpt_dir = ws / "04_Reports"
        rpt_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
        file_name = f"Audit_Certificate_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        
        s = {}
        if (ws / "stats.json").exists():
            with open(ws / "stats.json") as f: s = json.load(f)
        
        total_orig = 0
        total_new = 0
        errors = []
        
        if file_results:
            for res in file_results:
                total_orig += res.get('orig_size', 0)
                total_new += res.get('new_size', 0)
                if not res.get('ok', True):
                    errors.append(res)
        
        saved_bytes = total_orig - total_new
        saved_mb = round(saved_bytes / (1024 * 1024), 2)
        saved_pct = round((saved_bytes / total_orig * 100), 1) if total_orig > 0 else 0

        error_rows = ""
        if errors:
            rows = []
            for e in errors:
                fname = e.get('file', '?')
                err_msg = e.get('error', 'Unknown')
                rows.append(f"<tr class='error-row'><td>{fname}</td><td>FAILED</td><td>{err_msg}</td></tr>")
            error_rows = f"<table><thead><tr><th>File</th><th>Status</th><th>Error Details</th></tr></thead><tbody>{''.join(rows)}</tbody></table>"
        else:
            error_rows = "<p>No errors reported. Clean run.</p>"

        # (HTML generation logic preserved)
        html = f"""
        <html>
        <head>
            <style>
                body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 40px; background: #f0f2f5; color: #333; }}
                .container {{ background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); max-width: 900px; margin: auto; }}
                .header {{ border-bottom: 2px solid #0078d7; padding-bottom: 20px; margin-bottom: 30px; display: flex; justify-content: space-between; align-items: center; }}
                .title h1 {{ margin: 0; color: #2c3e50; font-size: 24px; }}
                .title span {{ color: #7f8c8d; font-size: 14px; }}
                .badge {{ background: #0078d7; color: white; padding: 5px 10px; border-radius: 4px; font-weight: bold; font-size: 12px; }}
                
                .grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }}
                .card {{ background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef; }}
                .card-label {{ font-size: 11px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; }}
                .card-value {{ font-size: 20px; font-weight: 600; color: #212529; }}
                .highlight {{ color: #28a745; }}
                
                table {{ width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 13px; }}
                th {{ text-align: left; border-bottom: 2px solid #dee2e6; padding: 10px; color: #495057; }}
                td {{ border-bottom: 1px solid #dee2e6; padding: 10px; }}
                .error-row {{ background-color: #fff5f5; color: #c0392b; }}
                
                .footer {{ margin-top: 40px; font-size: 11px; color: #adb5bd; text-align: center; border-top: 1px solid #eee; padding-top: 20px; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <div class="title">
                        <h1>Processing Audit Certificate</h1>
                        <span>DocRefine Pro {SystemUtils.CURRENT_VERSION}</span>
                    </div>
                    <span class="badge">COMPLETED</span>
                </div>
                
                <p><strong>Operation:</strong> {action_name}<br><strong>Timestamp:</strong> {timestamp}</p>
                
                <div class="grid">
                    <div class="card">
                        <div class="card-label">Files Processed</div>
                        <div class="card-value">{len(file_results) if file_results else s.get('total_scanned', 0)}</div>
                    </div>
                    <div class="card">
                        <div class="card-label">Storage Reclaimed</div>
                        <div class="card-value highlight">{saved_mb} MB ({saved_pct}%)</div>
                    </div>
                    <div class="card">
                        <div class="card-label">Failed / Skipped</div>
                        <div class="card-value" style="color: {'red' if errors else '#212529'}">{len(errors)}</div>
                    </div>
                    <div class="card">
                        <div class="card-label">Duration</div>
                        <div class="card-value">{str(timedelta(seconds=int(s.get('batch_time', 0) + s.get('ingest_time', 0))))}</div>
                    </div>
                </div>

                <h3>Exceptions & Errors</h3>
                {error_rows}
                
                <div class="footer">
                    This document certifies that the files listed above were processed by the DocRefine Engine.<br>
                    Generated automatically on {timestamp}
                </div>
            </div>
        </body>
        </html>
        """
        
        with open(rpt_dir / file_name, "w", encoding="utf-8") as f:
            f.write(html)
        return str(rpt_dir / file_name)
    except Exception as e:
        print(f"Report Gen Error: {e}")
        return None

# ==============================================================================
#   WORKER CLASS (REFACTORED FOR EVENTS)
# ==============================================================================
class Worker:
    def __init__(self, callback): 
        # REFACTORED: Accepts a generic callback instead of a queue
        self.callback = callback 
        self.stop_sig = False
        self.pause_event = threading.Event()
        self.pause_event.set()
        self.current_ws = None 
        self._last_update = {}

    def emit(self, event: AppEvent):
        """Bridge to the observer (UI/CLI)"""
        if self.callback:
            self.callback(event)

    def stop(self): 
        self.stop_sig = True
        self.pause_event.set()

    def pause(self): 
        self.pause_event.clear()

    def resume(self): 
        self.pause_event.set()

    def log(self, m, err=False):
        # REFACTORED: Uses Event System
        level = "ERROR" if err else "INFO"
        self.emit(AppEvent.log(m, level))
        log_app(m, level, structured_data={"ws": self.current_ws})

    def set_job_status(self, ws, stage, details=""):
        try:
            data = { "stage": stage, "last_update": datetime.now().strftime('%Y-%m-%d %H:%M:%S'), "details": details }
            with open(Path(ws) / "status.json", 'w') as f: json.dump(data, f, indent=4)
        except: pass

    def prog_main(self, v, t): 
        # REFACTORED
        self.emit(AppEvent.progress(v, t))
    
    def prog_sub(self, v, t, status_only=False): 
        # REFACTORED
        tid = threading.get_ident()
        now = time.time()
        
        if tid not in self._last_update:
            self._last_update[tid] = 0
            
        if (now - self._last_update[tid]) > 0.1: # Max 10 updates/sec per thread
            # Emitting structured slot data
            self.emit(AppEvent(EventType.SLOT_UPDATE, {"tid": tid, "text": t, "percent": v}))
            self._last_update[tid] = now

    def get_hash(self, path, mode):
        # (Logic preserved from v118)
        if os.path.getsize(path) == 0: return None, "Zero-Byte File"
        if path.suffix.lower() == '.pdf' and mode != "Lightning":
            try:
                if PdfReader is None: raise Exception("pypdf not available")
                r = PdfReader(str(path), strict=False) 
                if len(r.pages) == 0: return None, "PDF has 0 Pages"
                if mode == "Standard":
                    txt = "".join([r.pages[i].extract_text() for i in range(min(3, len(r.pages)))])
                    if len(txt.strip()) > 10: return hashlib.md5(f"{txt}{len(r.pages)}".encode()).hexdigest(), "Smart-Standard"
                elif mode == "Deep":
                    txt = "".join([p.extract_text() for p in r.pages])
                    if len(txt.strip()) > 10: return hashlib.md5(f"{txt}{len(r.pages)}".encode()).hexdigest(), "Smart-Deep"
            except: pass 
        try:
            h = hashlib.md5()
            with open(path, 'rb') as f:
                for chunk in iter(lambda: f.read(65536), b""): h.update(chunk)
            return h.hexdigest(), "Binary"
        except Exception as e: return None, f"Read-Error: {str(e)[:20]}"

    def get_best_source(self, ws, file_uid, priority_mode="Auto (Best Available)"):
        # (Logic preserved from v118)
        master = ws / "01_Master_Files" / file_uid
        base_cache = ws / "02_Ready_For_Redistribution"
        
        def find_in_dir(d, stem):
            if d.exists():
                if (d / file_uid).exists(): return d / file_uid
                match = next((f for f in d.iterdir() if f.stem == stem), None)
                if match: return match
            return None

        stem = Path(file_uid).stem
        
        if "Force: OCR" in priority_mode:
            f = find_in_dir(base_cache/"OCR", stem)
            return f if f else master
            
        elif "Force: Flattened" in priority_mode:
            f = find_in_dir(base_cache/"Flattened", stem)
            return f if f else master
            
        elif "Force: Original" in priority_mode:
            return master
            
        else: 
            for sub in ["OCR", "Flattened", "Resized", "Sanitized", "Standard"]:
                f = find_in_dir(base_cache/sub, stem)
                if f: return f
            return master if master.exists() else None

    def run_inventory(self, d_str, ingest_mode):
        try:
            self.stop_sig = False
            self.resume()
            
            d = Path(d_str); start_time = time.time()
            ws = WORKSPACES_ROOT / f"{d.name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            m_dir = ws / "01_Master_Files"; m_dir.mkdir(parents=True); (ws/"00_Quarantine").mkdir()
            self.current_ws = str(ws); self.log(f"Inventory Start: {d}")
            
            # REFACTORED
            self.emit(AppEvent(EventType.JOB_DATA, str(ws)))
            self.set_job_status(ws, "SCANNING", "Ingesting...")
            
            files = [Path(r)/f for r,_,fs in os.walk(d) for f in fs]
            files = [f for f in files if f.suffix.lower() in SUPPORTED_EXTENSIONS]
            
            seen = {}; quarantined = 0
            
            # REFACTORED
            self.emit(AppEvent(EventType.WORKER_CONFIG, 1))

            for i, f in enumerate(files):
                if self.stop_sig: break
                if not self.pause_event.is_set(): self.prog_sub(None, "Paused...", True); self.pause_event.wait()
                
                self.prog_main((i/len(files))*100, f"Scanning {i}/{len(files)}")
                self.prog_sub(None, f"Hashing: {f.name}", True)
                
                try:
                    h, method = self.get_hash(f, ingest_mode)
                    if not h: 
                        self.log(f"‚ö†Ô∏è Quarantine: {f.name}", True)
                        shutil.copy2(f, ws/"00_Quarantine"/f"{uuid.uuid4()}_{sanitize_filename(f.name)}")
                        quarantined += 1; continue
                    
                    rel = str(f.relative_to(d))
                    if h in seen: seen[h]['copies'].append(rel)
                    else: seen[h] = {'master': rel, 'copies': [rel], 'name': f.name, 'root': str(d)}
                except Exception as e:
                    self.log(f"Hash Error: {e}", True)

            if self.stop_sig: 
                self.log("Ingest Stopped by User.")
                self.emit(AppEvent(EventType.DONE))
                return

            self.log("Tagging..."); total = len(seen)
            for i, (h, data) in enumerate(seen.items()):
                if self.stop_sig: break
                safe_name = f"[{i+1:04d}]_{sanitize_filename(data['name'])}"
                shutil.copy2(d / data['master'], m_dir / safe_name)
                data['uid'] = safe_name; data['id'] = f"[{i+1:04d}]"
            
            if self.stop_sig: return

            stats = {
                "ingest_time": time.time()-start_time, 
                "masters": total, 
                "quarantined": quarantined,
                "total_scanned": len(files)
            }
            with open(ws/"manifest.json", 'w') as f: json.dump(seen, f, indent=4)
            with open(ws/"stats.json", 'w') as f: json.dump(stats, f)
            self.set_job_status(ws, "INGESTED", f"Masters: {total}")
            self.log(f"Done. Masters: {total}")
            
            # REFACTORED
            self.emit(AppEvent(EventType.JOB_DATA, str(ws)))
            self.emit(AppEvent(EventType.DONE))
            
        except Exception as e: 
            self.log(f"Error: {e}", True)
            self.emit(AppEvent(EventType.DONE))

    def process_file_task(self, f, bots, options, base_dst):
        # (Logic preserved from v118, updated logs/events only)
        if self.stop_sig: return None
        result = {'file': f.name, 'orig_size': f.stat().st_size, 'new_size': 0, 'ok': False}
        try:
            # REFACTORED
            self.emit(AppEvent.status("PROCESSING", f"Refining: {f.name}", "blue"))
            
            ext = f.suffix.lower()
            ok = False
            dpi_val = int(options.get('dpi', 300))
            
            target_folder = "Standard"
            
            if ext == '.pdf':
                mode = options.get('pdf_mode', 'none')
                if mode == 'flatten': target_folder = "Flattened"
                elif mode == 'ocr': target_folder = "OCR"
            elif ext in {'.jpg','.png'}:
                if options.get('resize'): target_folder = "Resized"
                if options.get('img2pdf'): target_folder = "Resized" 
            elif ext in {'.docx','.xlsx'}:
                if options.get('sanitize'): target_folder = "Sanitized"
            
            final_dst_dir = base_dst / target_folder
            final_dst_dir.mkdir(parents=True, exist_ok=True)
            
            dst_file = final_dst_dir / f.name

            if ext == '.pdf':
                mode = options.get('pdf_mode', 'none')
                if mode == 'flatten': ok = bots['pdf'].flatten_or_ocr(f, dst_file, 'flatten', dpi=dpi_val)
                elif mode == 'ocr': ok = bots['pdf'].flatten_or_ocr(f, dst_file, 'ocr', dpi=dpi_val)
            elif ext in {'.jpg','.png'}:
                if options.get('resize'): ok = bots['img'].resize(f, dst_file, CFG.get('resize_width'))
                if options.get('img2pdf'): ok = bots['img'].convert_to_pdf(f, final_dst_dir/f"{f.stem}.pdf")
            elif ext in {'.docx','.xlsx'}:
                if options.get('sanitize'): ok = bots['office'].sanitize(f, dst_file)

            if not ok and not dst_file.exists(): 
                 shutil.copy2(f, dst_file)
            
            if dst_file.exists():
                result['new_size'] = dst_file.stat().st_size
                result['ok'] = True
            
            return result
                 
        except Exception as e:
            self.log(f"Err {f.name}: {e}", True)
            result['error'] = str(e)
            return result

    def run_batch(self, ws_p, options):
        try:
            self.stop_sig = False
            self.resume()
            
            ws = Path(ws_p); self.current_ws = str(ws)
            start_time = time.time(); src = ws/"01_Master_Files"; dst = ws/"02_Ready_For_Redistribution"; dst.mkdir(exist_ok=True)
            self.log(f"Refinement Start. Opts: {options}")
            self.set_job_status(ws, "PROCESSING", "Refining...")

            # Use imported Processors
            bots = {
                'pdf': PdfProcessor(lambda v,t,s=False: self.prog_sub(v,t,s), lambda: self.stop_sig, self.pause_event),
                'img': ImageProcessor(lambda v,t,s=False: self.prog_sub(v,t,s), lambda: self.stop_sig, self.pause_event),
                'office': OfficeProcessor(lambda v,t,s=False: self.prog_sub(v,t,s), lambda: self.stop_sig, self.pause_event)
            }
            fs = list(src.iterdir())
            
            forced_workers = int(CFG.get("max_threads"))
            if forced_workers > 0:
                max_workers = forced_workers
                self.log(f"Manual Worker Override: {max_workers}")
            else:
                max_workers = 2
                if HAS_PSUTIL:
                    try:
                        total_ram_gb = psutil.virtual_memory().total / (1024 ** 3)
                        if total_ram_gb < 8: max_workers = 1
                        elif total_ram_gb < 16: max_workers = 2
                        else: max_workers = 4
                    except: pass
                
                max_workers = min(max_workers, os.cpu_count() or 1)
                max_workers = max(1, max_workers)
                self.log(f"Auto-Throttled Workers: {max_workers}")

            # REFACTORED
            self.emit(AppEvent(EventType.WORKER_CONFIG, max_workers))
            
            file_results = []
            with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = {executor.submit(self.process_file_task, f, bots, options, dst): f for f in fs}
                for i, future in enumerate(concurrent.futures.as_completed(futures)):
                    if self.stop_sig: break
                    self.prog_main((i/len(fs))*100, f"Refining {i+1}/{len(fs)}")
                    try: 
                        r = future.result()
                        if r: file_results.append(r)
                    except Exception as e: self.log(f"Thread Err: {e}", True)

            if self.stop_sig: 
                self.log("Batch Stopped by User.")
                self.emit(AppEvent(EventType.DONE))
                return

            update_stats_time(ws, "batch_time", time.time() - start_time)
            self.set_job_status(ws, "PROCESSED", "Complete")
            
            rpt = generate_job_report(ws, "Content Refinement Batch", file_results)
            if rpt: self.log(f"Receipt Generated: {Path(rpt).name}")
            
            self.emit(AppEvent(EventType.JOB_DATA, str(ws))) 
            self.prog_main(100, "Done")
            
            # REFACTORED: Send notification instead of direct open_file (though standard behavior can be handled in adapter)
            self.emit(AppEvent(EventType.DONE))
            self.emit(AppEvent(EventType.NOTIFICATION, {"title": "Batch Complete", "msg": "Batch processing finished.", "open_path": str(dst)}))
            
        except Exception as e: 
            self.log(f"Err: {e}", True)
            self.emit(AppEvent(EventType.DONE))

    def run_organize(self, ws_p, priority_mode):
        try:
            self.stop_sig = False; self.resume()
            ws = Path(ws_p); self.current_ws = str(ws)
            start_time = time.time()
            out = ws / "03_Organized_Output"; m = out/"Unique_Masters"; q = out/"Quarantine"
            for p in [m,q]: p.mkdir(parents=True, exist_ok=True)
            
            self.log(f"Unique Export ({priority_mode})")
            with open(ws/"manifest.json") as f: man = json.load(f)
            total = len(man)
            
            # REFACTORED
            self.emit(AppEvent(EventType.WORKER_CONFIG, 1))

            dup_csv = out / "duplicates_report.csv"
            with open(dup_csv, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(["Master_Filename", "Duplicate_Location"])
                
                for i, (h, data) in enumerate(man.items()):
                    if self.stop_sig: break
                    self.prog_main((i/total)*100, "Exporting Unique...")
                    # REFACTORED
                    self.emit(AppEvent(EventType.SLOT_UPDATE, {"tid": threading.get_ident(), "text": f"Exporting: {data['name']}", "percent": None}))
                    
                    if data.get("status") == "QUARANTINE": 
                        for f in (ws/"00_Quarantine").glob("*"):
                            if data['orig_name'] in f.name: shutil.copy2(f, q/f.name)
                    else:
                        src = self.get_best_source(ws, data['uid'], priority_mode)
                        if src and src.exists():
                            clean_name = data['name']
                            if src.suffix != Path(clean_name).suffix:
                                clean_name = Path(clean_name).stem + src.suffix

                            tgt = m / clean_name
                            ctr = 1
                            while tgt.exists():
                                tgt = m / f"{Path(clean_name).stem}_{ctr}{Path(clean_name).suffix}"
                                ctr += 1
                            shutil.copy2(src, tgt)

                        if len(data.get('copies', [])) > 1:
                            for c in data['copies']:
                                if c != data.get('master'):
                                    writer.writerow([data['name'], c])

            if self.stop_sig: return

            update_stats_time(ws, "organize_time", time.time() - start_time)
            self.set_job_status(ws, "ORGANIZED", "Done")
            
            rpt = generate_job_report(ws, f"Unique Export ({priority_mode})")
            
            self.emit(AppEvent(EventType.JOB_DATA, str(ws))) 
            self.prog_main(100, "Done")
            self.emit(AppEvent(EventType.DONE))
            self.emit(AppEvent(EventType.NOTIFICATION, {"title": "Organization Complete", "msg": "Files organized.", "open_path": str(out)}))
            
        except Exception as e: 
            self.log(f"Err: {e}", True)
            self.emit(AppEvent(EventType.DONE))

    def run_distribute(self, ws_p, ext_src, priority_mode):
        try:
            self.stop_sig = False; self.resume()
            ws = Path(ws_p); self.current_ws = str(ws)
            if not (ws/"manifest.json").exists():
                 self.log("CRITICAL: Manifest missing.", True)
                 self.emit(AppEvent(EventType.ERROR, "Manifest missing."))
                 self.emit(AppEvent(EventType.DONE))
                 return

            start_time = time.time(); 
            dst = ws / "Final_Delivery"
            self.log(f"Reconstruction Start ({priority_mode})")
            self.set_job_status(ws, "DISTRIBUTING", "Reconstructing...")
            
            with open(ws/"manifest.json") as f: man = json.load(f)
            
            orphans = {}
            if ext_src:
                 orphans = {f.name: f for f in Path(ext_src).iterdir()}

            self.emit(AppEvent(EventType.WORKER_CONFIG, 1))

            for i, (h, d) in enumerate(man.items()):
                if self.stop_sig: break
                self.prog_main((i/len(man))*100, f"Recon {i+1}")
                self.emit(AppEvent(EventType.SLOT_UPDATE, {"tid": threading.get_ident(), "text": f"Copying: {d['name']}", "percent": None}))
                
                if d.get("status") == "QUARANTINE": continue
                
                src = None
                if ext_src:
                    src = next((v for k,v in orphans.items() if k.startswith(d['id'])), None)
                else:
                    src = self.get_best_source(ws, d['uid'], priority_mode)
                
                if not src: continue
                
                for c in d['copies']:
                    t = dst / c; t.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(src, t.with_suffix(src.suffix))
            
            if self.stop_sig: return

            q_src = ws / "00_Quarantine"
            if q_src.exists():
                q_dst = dst / "_QUARANTINED_FILES"; 
                q_dst.mkdir(parents=True, exist_ok=True) 
                for qf in q_src.iterdir(): shutil.copy2(qf, q_dst / qf.name)

            update_stats_time(ws, "dist_time", time.time() - start_time)
            self.set_job_status(ws, "DISTRIBUTED", "Done")
            
            rpt = generate_job_report(ws, "Full Reconstruction")
            
            self.emit(AppEvent(EventType.JOB_DATA, str(ws))) 
            self.prog_main(100, "Done")
            self.emit(AppEvent(EventType.DONE))
            self.emit(AppEvent(EventType.NOTIFICATION, {"title": "Distribution Complete", "msg": "Reconstruction finished.", "open_path": str(dst)}))
            
        except Exception as e: 
            self.log(f"Err: {e}", True)
            self.emit(AppEvent(EventType.DONE))

    def run_full_export(self, ws_p):
        try:
            self.stop_sig = False; self.resume()
            ws = Path(ws_p); self.current_ws = str(ws)
            if not (ws/"manifest.json").exists(): return

            rpt_dir = ws / "04_Reports"
            rpt_dir.mkdir(parents=True, exist_ok=True)
            csv_path = rpt_dir / "Full_Inventory_Manifest.csv"

            self.log("Generating Full Inventory CSV...")
            
            with open(ws/"manifest.json") as f: man = json.load(f)
            
            try:
                # utf-8-sig for Excel compatibility with special chars
                with open(csv_path, 'w', newline='', encoding='utf-8-sig') as csvfile:
                    writer = csv.writer(csvfile)
                    writer.writerow(["ID", "Status", "Original_Filename", "Original_Path_Structure", "Master_Location_In_Workplace", "Hash_Type", "Hash", "Copy_Count", "Error_Details"])
                    
                    total = len(man)
                    for i, (h, data) in enumerate(man.items()):
                        if self.stop_sig: break
                        self.prog_main((i/total)*100, "Writing CSV...")
                        
                        uid = data.get('id', '?')
                        status = data.get('status', 'OK')
                        name = data.get('name', '?')
                        master_rel = data.get('master', '')
                        
                        if status == "QUARANTINE":
                            orig = data.get('orig_name', name)
                            writer.writerow([uid, status, orig, "N/A - Quarantined", "00_Quarantine", "Binary", h, 0, data.get('error_reason', '')])
                        else:
                            copies = data.get('copies', [])
                            for copy_path in copies:
                                writer.writerow([
                                    uid, 
                                    status, 
                                    name, 
                                    copy_path, 
                                    master_rel, 
                                    "MD5", 
                                    h, 
                                    len(copies), 
                                    ""
                                ])
            except PermissionError:
                self.emit(AppEvent(EventType.ERROR, "Could not write CSV.\nPlease close the file in Excel and try again."))
                self.emit(AppEvent(EventType.DONE))
                return

            if self.stop_sig: return

            self.log(f"Exported: {csv_path.name}")
            self.emit(AppEvent(EventType.JOB_DATA, str(ws))) 
            self.prog_main(100, "Done")
            self.emit(AppEvent(EventType.DONE))
            self.emit(AppEvent(EventType.NOTIFICATION, {"title": "CSV Exported", "msg": "Inventory saved.", "open_path": str(rpt_dir)}))

        except Exception as e: 
            self.log(f"Err: {e}", True)
            self.emit(AppEvent(EventType.DONE))

    def run_preview(self, ws_p, dpi):
        try:
            self.stop_sig = False; self.resume()
            ws = Path(ws_p); self.current_ws = str(ws)
            src = ws/"01_Master_Files"; pdf = next(src.glob("*.pdf"), None)
            
            if not pdf: 
                # REFACTORED: Status + Done
                self.emit(AppEvent.status("PREVIEW", "No PDF found.", "red"))
                self.emit(AppEvent(EventType.DONE))
                return
                
            for old in ws.glob("PREVIEW_*.pdf"): 
                try: os.remove(old)
                except: pass
            
            out = ws / f"PREVIEW_{int(time.time())}.pdf"
            imgs = convert_from_path(str(pdf), dpi=int(dpi), first_page=1, last_page=1, poppler_path=POPPLER_BIN)
            if imgs: 
                imgs[0].save(out, "PDF", resolution=float(dpi))
                self.emit(AppEvent(EventType.NOTIFICATION, {"title": "Preview Ready", "msg": "Opening preview...", "open_path": str(out)}))
            
            self.emit(AppEvent.status("PREVIEW", "Preview Generated", "green"))
            self.emit(AppEvent(EventType.DONE))
            
        except: 
            self.emit(AppEvent(EventType.DONE))

    def run_debug_export(self, ws_path_str):
        try:
            ts = datetime.now().strftime('%Y%m%d_%H%M%S')
            base_dir = SystemUtils.get_user_data_dir()
            
            try:
                test_file = base_dir / "write_test.tmp"
                test_file.touch()
                test_file.unlink()
            except PermissionError:
                if SystemUtils.IS_MAC:
                    base_dir = Path.home() / "Downloads"
                else:
                    base_dir = Path(os.getenv('TEMP', '/tmp'))
            
            dest_zip = base_dir / f"Debug_Bundle_{ts}.zip"
            temp_dir = base_dir / f"temp_debug_{ts}"
            temp_dir.mkdir(parents=True, exist_ok=True)
            
            def safe_copy(src, dst_name):
                try:
                    if not src or not Path(src).exists(): return
                    try:
                        shutil.copy2(src, temp_dir / dst_name)
                    except PermissionError:
                        with open(src, 'rb') as f_in:
                            content = f_in.read()
                        with open(temp_dir / dst_name, 'wb') as f_out:
                            f_out.write(content)
                except Exception as e:
                    with open(temp_dir / f"{dst_name}_ERROR.txt", 'w') as err_f:
                        err_f.write(str(e))

            # Core Logs
            safe_copy(LOG_PATH, "app_debug.log")
            safe_copy(JSON_LOG_PATH, "app_events.jsonl")
            safe_copy(CFG.path, "config.json")
            
            # Current WS
            if ws_path_str:
                ws = Path(ws_path_str)
                if ws.exists():
                    safe_copy(ws/"session_log.txt", "current_job_log.txt")
                    safe_copy(ws/"stats.json", "current_job_stats.json")
            
            shutil.make_archive(str(dest_zip).replace(".zip", ""), 'zip', temp_dir)
            shutil.rmtree(temp_dir, ignore_errors=True)
            
            # REFACTORED
            self.emit(AppEvent(EventType.NOTIFICATION, {"title": "Debug Export", "msg": f"Saved to {dest_zip.name}", "open_path": str(base_dir)}))
            
        except Exception as e:
            self.emit(AppEvent(EventType.ERROR, f"Export Failed: {e}"))
==================== END FILE: docrefine\worker.py ====================


==================== START FILE: docrefine\__init__.py ====================

==================== END FILE: docrefine\__init__.py ====================


==================== START FILE: docrefine\core\events.py ====================
# SAVE AS: docrefine/core/events.py
from dataclasses import dataclass
from enum import Enum, auto
from typing import Any, Optional

class EventType(Enum):
    LOG = auto()
    PROGRESS_MAIN = auto()
    SLOT_UPDATE = auto()    # Individual thread update
    WORKER_CONFIG = auto()  # Setup thread slots
    STATUS_CHANGE = auto()
    JOB_DATA = auto()       # Refresh job list
    NOTIFICATION = auto()   # Popups/Dialogs
    ERROR = auto()
    DONE = auto()

@dataclass
class AppEvent:
    type: EventType
    payload: Any = None

    @staticmethod
    def log(msg: str, level: str = "INFO"):
        return AppEvent(EventType.LOG, {"msg": msg, "level": level})

    @staticmethod
    def progress(percent: float, text: str = ""):
        return AppEvent(EventType.PROGRESS_MAIN, {"percent": percent, "text": text})

    @staticmethod
    def status(stage: str, message: str, color_hint: str = "blue"):
        return AppEvent(EventType.STATUS_CHANGE, {"stage": stage, "msg": message, "color": color_hint})
==================== END FILE: docrefine\core\events.py ====================


==================== START FILE: docrefine\gui\app.py ====================
import tkinter as tk
from tkinter import filedialog, scrolledtext, messagebox, ttk, Menu
import threading
import queue
import time
import json
import os
import shutil
import ssl
import urllib.request
import webbrowser
import platform
import uuid
import re
from pathlib import Path
from datetime import datetime, timedelta
from PIL import Image, ImageTk

# 3rd Party (Optional UI dependencies)
try:
    import pytesseract
except ImportError:
    pass

# Local Package Imports
from ..config import CFG, SystemUtils, LOG_PATH, WORKSPACES_ROOT
from ..worker import Worker, HAS_TESSERACT, POPPLER_BIN
from ..processing import convert_from_path, pdfinfo_from_path

# ==============================================================================
#   UI HELPERS
# ==============================================================================
def get_tesseract_langs():
    if not HAS_TESSERACT: return ["N/A"]
    try:
        raw_langs = pytesseract.get_languages(config='')
        friendly_map = {
            'eng': 'English', 'spa': 'Spanish', 'fra': 'French', 'deu': 'German',
            'ita': 'Italian', 'por': 'Portuguese', 'chi_sim': 'Chinese (Simp)',
            'jpn': 'Japanese', 'rus': 'Russian'
        }
        clean = []
        for l in raw_langs:
            if l == 'osd': continue
            name = friendly_map.get(l, l)
            if name != l: clean.append(f"{name} ({l})")
            else: clean.append(l)
        return sorted(clean)
    except: return ["eng"]

def parse_lang_code(selection):
    if "(" in selection and ")" in selection:
        return selection.split("(")[1].replace(")", "")
    return selection

def sanitize_filename(name):
    return re.sub(r'[<>:"/\\|?*]', '_', name)

# ==============================================================================
#   SUB-WINDOWS
# ==============================================================================
class DocViewer:
    def __init__(self, root, filename, title):
        self.win = tk.Toplevel(root)
        self.win.title(title)
        self.win.geometry("800x600")
        App.center_toplevel(self.win, root)
        
        target = SystemUtils.find_doc_file(filename)
        
        if not target:
            tk.Label(self.win, text=f"File '{filename}' not found.", font=("Segoe UI", 12, "bold"), fg="red").pack(pady=20)
            tk.Label(self.win, text="Please ensure the file is present in the application folder.", font=("Segoe UI", 10)).pack()
            return
            
        txt = scrolledtext.ScrolledText(self.win, wrap="word", font=("Consolas", 10), padx=10, pady=10)
        txt.pack(fill="both", expand=True)
        
        try:
            content = target.read_text(encoding='utf-8')
            txt.insert("1.0", content)
        except Exception as e:
            txt.insert("1.0", f"Error reading file: {e}")
            
        txt.config(state="disabled")

class ForensicComparator:
    def __init__(self, root, ws_path, manifest, master_path, dup_candidates):
        self.win = tk.Toplevel(root)
        self.win.title("Forensic Verification (Sync View)")
        self.win.geometry("1400x800")
        App.center_toplevel(self.win, root)
        
        self.ws_path = ws_path
        self.manifest = manifest
        self.master_path = master_path
        self.dups = dup_candidates
        self.dup_idx = 0
        self.page = 1
        self.total_pages = 1
        self.zoom = 1.0
        self.last_scroll_time = 0
        
        self.top = tk.Frame(self.win, bg="#eee", pady=5)
        self.top.pack(fill="x")
        
        self.lbl_info = tk.Frame(self.win)
        self.lbl_info.pack(fill="x", pady=2)
        tk.Label(self.lbl_info, text=f"MASTER: {master_path.name}", font=("Consolas", 9, "bold"), fg="#2c3e50").pack(side="left", fill="x", expand=True)
        tk.Label(self.lbl_info, text="CANDIDATE (DUPLICATE)", font=("Consolas", 9, "bold"), fg="#c0392b").pack(side="left", fill="x", expand=True)

        self.mid = tk.Frame(self.win)
        self.mid.pack(fill="both", expand=True)
        
        self.c1 = tk.Canvas(self.mid, bg="#444", scrollregion=(0,0,1000,1000))
        self.c1.pack(side="left", fill="both", expand=True)
        
        self.sep = ttk.Separator(self.mid, orient="vertical")
        self.sep.pack(side="left", fill="y", padx=5)
        
        self.c2 = tk.Canvas(self.mid, bg="#444", scrollregion=(0,0,1000,1000))
        self.c2.pack(side="left", fill="both", expand=True)
        
        self._build_toolbar()
        
        self.is_pdf = self.master_path.suffix.lower() == '.pdf'
        if self.is_pdf:
            try: self.total_pages = pdfinfo_from_path(str(self.master_path), poppler_path=POPPLER_BIN).get('Pages', 1)
            except: self.total_pages = 1
            
        self.load_images()
        self.bind_events()

    def _build_toolbar(self):
        f_page = tk.Frame(self.top); f_page.pack(side="left", padx=10)
        tk.Button(f_page, text="< Prev Page", command=self.prev_page).pack(side="left")
        self.lbl_page = tk.Label(f_page, text="Page 1/1", width=10)
        self.lbl_page.pack(side="left", padx=5)
        tk.Button(f_page, text="Next Page >", command=self.next_page).pack(side="left")
        
        f_zoom = tk.Frame(self.top); f_zoom.pack(side="left", padx=20)
        tk.Button(f_zoom, text="- Zoom", command=lambda: self.do_zoom(0.8)).pack(side="left")
        self.lbl_zoom = tk.Label(f_zoom, text="100%", width=6)
        self.lbl_zoom.pack(side="left")
        tk.Button(f_zoom, text="Zoom +", command=lambda: self.do_zoom(1.2)).pack(side="left")
        tk.Button(f_zoom, text="[Fit Width]", command=self.fit_width).pack(side="left", padx=5)
        
        f_dup = tk.Frame(self.top); f_dup.pack(side="right", padx=10)
        tk.Button(f_dup, text="< Prev Copy", command=self.prev_dup).pack(side="left")
        self.lbl_dup = tk.Label(f_dup, text="Copy 1/1", width=15)
        self.lbl_dup.pack(side="left", padx=5)
        tk.Button(f_dup, text="Next Copy >", command=self.next_dup).pack(side="left")
        tk.Button(f_dup, text="Open File", command=self.open_current_dup).pack(side="left", padx=5)
        
        kw_uniq = {"bg": "green", "fg": "white"} if not SystemUtils.IS_MAC else {}
        tk.Button(f_dup, text="MARK AS UNIQUE", command=self.mark_as_unique, **kw_uniq).pack(side="left", padx=10)

    def load_images(self):
        self.lbl_page.config(text=f"Page {self.page}/{self.total_pages}")
        self.lbl_zoom.config(text=f"{int(self.zoom*100)}%")
        self.lbl_dup.config(text=f"Copy {self.dup_idx+1}/{len(self.dups)}")
        
        if self.dups:
            path_str = str(self.dups[self.dup_idx])
            if len(path_str) > 60: path_str = "..." + path_str[-57:]
            tk.Label(self.lbl_info.winfo_children()[1], text=path_str).pack_forget() 
            self.lbl_info.winfo_children()[1].config(text=f"CANDIDATE: {path_str}")

        self.img1 = self._render(self.master_path)
        self.show_img(self.c1, self.img1)
        
        if self.dups:
            dup_path = self.dups[self.dup_idx]
            self.img2 = self._render(dup_path)
            self.show_img(self.c2, self.img2)
        else:
            self.c2.delete("all")

    def _render(self, path):
        try:
            if not Path(path).exists(): return None
            img = None
            if Path(path).suffix.lower() == '.pdf':
                imgs = convert_from_path(str(path), dpi=int(72*self.zoom), first_page=self.page, last_page=self.page, poppler_path=POPPLER_BIN)
                if imgs: img = imgs[0]
            else:
                img = Image.open(str(path))
                w, h = img.size
                img = img.resize((int(w*self.zoom), int(h*self.zoom)))
            
            return ImageTk.PhotoImage(img) if img else None
        except: return None

    def show_img(self, cv, photo):
        cv.delete("all")
        if photo:
            cv.create_image(0,0, image=photo, anchor="nw")
            cv.config(scrollregion=cv.bbox("all"))

    def bind_events(self):
        self.c1.bind("<MouseWheel>", self.on_scroll_page)
        self.c2.bind("<MouseWheel>", self.on_scroll_page)
        self.c1.bind("<Button-4>", self.on_scroll_page)
        self.c1.bind("<Button-5>", self.on_scroll_page)
        self.c1.bind("<ButtonPress-1>", self.scroll_start)
        self.c1.bind("<B1-Motion>", self.scroll_move)
        self.c2.bind("<ButtonPress-1>", self.scroll_start)
        self.c2.bind("<B1-Motion>", self.scroll_move)

    def on_scroll_page(self, event):
        now = time.time()
        if now - self.last_scroll_time < 0.4: return
        self.last_scroll_time = now

        d = 0
        if event.num == 5 or event.delta < 0: d = 1 
        elif event.num == 4 or event.delta > 0: d = -1 
        
        if d == 1: self.next_page()
        elif d == -1: self.prev_page()

    def scroll_start(self, event):
        self.c1.scan_mark(event.x, event.y)
        self.c2.scan_mark(event.x, event.y)

    def scroll_move(self, event):
        self.c1.scan_dragto(event.x, event.y, gain=1)
        self.c2.scan_dragto(event.x, event.y, gain=1)

    def do_zoom(self, factor):
        self.zoom *= factor
        self.load_images()

    def fit_width(self):
        try:
            cw = self.c1.winfo_width()
            if cw > 50:
                self.zoom = (cw - 20) / 600.0
                self.load_images()
        except: pass

    def next_page(self):
        if self.page < self.total_pages:
            self.page += 1
            self.load_images()

    def prev_page(self):
        if self.page > 1:
            self.page -= 1
            self.load_images()

    def next_dup(self):
        if self.dup_idx < len(self.dups)-1:
            self.dup_idx += 1
            self.load_images()

    def prev_dup(self):
        if self.dup_idx > 0:
            self.dup_idx -= 1
            self.load_images()

    def open_current_dup(self):
        if self.dups:
            SystemUtils.reveal_file(self.dups[self.dup_idx])

    def mark_as_unique(self):
        if not self.dups: return
        target_path = self.dups[self.dup_idx]
        
        if messagebox.askyesno("Promote File", f"Mark '{target_path.name}' as a unique Master file?\n\nIt will be removed from this duplicate list and treated as a distinct document."):
            try:
                root_path = None
                original_hash = None
                
                for h, data in self.manifest.items():
                    r_p = data.get('root')
                    if r_p:
                        try:
                            rel_p = str(target_path.relative_to(r_p))
                            if rel_p in data['copies']:
                                original_hash = h
                                root_path = r_p
                                break
                        except: continue

                if original_hash:
                    rel_p = str(target_path.relative_to(root_path))
                    if rel_p in self.manifest[original_hash]['copies']:
                        self.manifest[original_hash]['copies'].remove(rel_p)

                    new_uid = f"{uuid.uuid4()}_{sanitize_filename(target_path.name)}"
                    new_key = f"PROMOTED_{uuid.uuid4()}"
                    
                    self.manifest[new_key] = {
                        "master": rel_p,
                        "copies": [rel_p],
                        "name": target_path.name,
                        "root": root_path,
                        "uid": new_uid,
                        "id": "PROMOTED",
                        "status": "OK"
                    }
                    
                    m_dir = self.ws_path / "01_Master_Files"
                    shutil.copy2(target_path, m_dir / new_uid)

                    with open(self.ws_path / "manifest.json", 'w') as f:
                        json.dump(self.manifest, f, indent=4)

                    del self.dups[self.dup_idx]
                    if not self.dups:
                        messagebox.showinfo("Done", "All duplicates handled.")
                        self.win.destroy()
                    else:
                        if self.dup_idx >= len(self.dups): self.dup_idx -= 1
                        self.load_images()
                else:
                    messagebox.showerror("Error", "Could not locate file in manifest structure.")

            except Exception as e:
                messagebox.showerror("Error", str(e))

# ==============================================================================
#   MAIN APPLICATION
# ==============================================================================
class App:
    def __init__(self, root):
        self.root = root
        self.root.title(f"DocRefine Pro {SystemUtils.CURRENT_VERSION} ({platform.system()})")
        
        self.apply_smart_geometry(CFG.get("last_geometry"))
        
        self.q = queue.Queue(); self.worker = Worker(self.q)
        self.start_t = 0; self.running = False; self.paused = False
        self.current_manifest = {}
        self.slot_widgets = {} 
        self.slot_frames = []
        self.context_menu = None 
        
        self.is_mac = SystemUtils.IS_MAC
        self.Btn = ttk.Button if self.is_mac else tk.Button
        self.style = ttk.Style()
        
        if self.is_mac: 
            self.style.theme_use('clam')
            self.style.configure("Treeview", background="white", foreground="black", fieldbackground="white")
            self.style.map("Treeview", background=[('selected', '#0078d7')])

        # --- LAYOUT ---
        left = tk.Frame(root, width=350); left.pack(side="left", fill="both", padx=10, pady=10)
        tk.Label(left, text="Workspace Dashboard", font=("Segoe UI", 12, "bold")).pack(pady=5)
        
        kw_new = {"bg": "#e3f2fd"} if not self.is_mac else {}
        self.btn_new = self.Btn(left, text="+ New Ingest Job", command=self.ask_ingest_mode, **kw_new)
        self.btn_new.pack(fill="x", pady=2)
        
        btn_row = tk.Frame(left); btn_row.pack(fill="x", pady=5)
        self.btn_refresh = self.Btn(btn_row, text="‚Üª Refresh", command=self.load_jobs); self.btn_refresh.pack(side="left", fill="x", expand=True)
        kw_del = {"bg": "#ffcdd2"} if not self.is_mac else {}
        self.btn_del = self.Btn(btn_row, text="üóë Delete", command=self.safe_delete_job, **kw_del); self.btn_del.pack(side="right")
        
        self.btn_upd = self.Btn(left, text="Check Updates", command=lambda: threading.Thread(target=self.check_updates, args=(True,), daemon=True).start())
        self.btn_upd.pack(anchor="w", pady=2)
        
        self.btn_settings = self.Btn(left, text="‚öô Settings", command=self.open_settings)
        self.btn_settings.pack(anchor="w", pady=2)

        self.btn_log = self.Btn(left, text="View App Log", command=self.open_app_log); self.btn_log.pack(anchor="w", pady=5)
        self.btn_open = self.Btn(left, text="Open Folder", command=self.open_f, state="disabled"); self.btn_open.pack(fill="x", pady=5)
        
        self.stats_fr = tk.LabelFrame(left, text="Stats", padx=5, pady=5); self.stats_fr.pack(fill="x")
        self.lbl_stats = tk.Label(self.stats_fr, text="Select a job...", anchor="w", justify="left"); self.lbl_stats.pack(fill="x")
        
        self.tree = ttk.Treeview(left, columns=("Name","Status","LastActive"), show="headings")
        for c, w in [("Name",140),("Status",70),("LastActive",110)]:
            self.tree.heading(c, text=c, command=lambda _c=c: self.sort_tree(self.tree,_c,False)); self.tree.column(c, width=w)
        self.tree.pack(fill="both", expand=True); self.tree.bind("<<TreeviewSelect>>", self.on_sel)
        
        right = tk.Frame(root); right.pack(side="right", fill="both", expand=True, padx=10, pady=10)
        self.nb = ttk.Notebook(right); self.nb.pack(fill="both", expand=True)
        
        self.tab_process = tk.Frame(self.nb); self.nb.add(self.tab_process, text=" 1. Refine ")
        self._build_refine()
        self.tab_dist = tk.Frame(self.nb); self.nb.add(self.tab_dist, text=" 2. Export ")
        self._build_export() 
        self.tab_inspect = tk.Frame(self.nb); self.nb.add(self.tab_inspect, text=" üîç Inspector ")
        self._build_inspect()
        
        mon = tk.LabelFrame(right, text="Process Monitor", padx=10, pady=10); mon.pack(fill="x", pady=10)
        head = tk.Frame(mon); head.pack(fill="x")
        
        status_fg = "blue" if not self.is_mac else "black"
        self.lbl_status = tk.Label(head, text="Ready", fg=status_fg, anchor="w", font=("Segoe UI", 9, "bold")); 
        self.lbl_status.pack(side="left", fill="x", expand=True)
        self.lbl_timer = tk.Label(head, text="00:00:00", font=("Consolas", 10)); self.lbl_timer.pack(side="right", padx=10)
        
        self.btn_receipt = self.Btn(head, text="View Receipt", command=self.open_receipt, state="disabled")
        self.btn_receipt.pack(side="right", padx=10)
        
        kw_stop = {"bg": "red", "fg": "white"} if not self.is_mac else {}
        self.btn_stop = self.Btn(head, text="STOP", command=self.stop, state="disabled", **kw_stop); self.btn_stop.pack(side="right")
        self.btn_pause = self.Btn(head, text="PAUSE", command=self.toggle_pause, state="disabled", width=8); self.btn_pause.pack(side="right", padx=5)

        tk.Label(mon, text="Overall Batch:", font=("Segoe UI", 8), anchor="w").pack(fill="x", pady=(5,0))
        self.p_main = tk.DoubleVar(); ttk.Progressbar(mon, variable=self.p_main).pack(fill="x", pady=2)
        
        self.frame_slots = tk.Frame(mon, pady=5)
        self.frame_slots.pack(fill="x")
        
        self.log_box = scrolledtext.ScrolledText(mon, height=8, bg="white", fg="black", insertbackground="black")
        self.log_box.pack(fill="both", expand=True)
        
        self.load_jobs()
        self.restore_session()
        
        self.poll()
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        
        threading.Thread(target=self.check_updates, args=(False,), daemon=True).start()

    def apply_smart_geometry(self, saved_geo):
        try:
            sw = self.root.winfo_screenwidth()
            sh = self.root.winfo_screenheight()
            
            if SystemUtils.IS_MAC: sh -= 120 
            else: sh -= 60 
            
            if SystemUtils.IS_MAC: w, h = 1280, 850
            else: w, h = 1024, 700
            
            x, y = 0, 0
            
            if saved_geo:
                parts = re.split(r'[x+]', saved_geo)
                if len(parts) == 4:
                    w, h, x, y = map(int, parts)
            
            if w > (sw * 0.95): 
                w = int(sw * 0.8)
                h = int(sh * 0.8)
                x = (sw // 2) - (w // 2)
                y = (sh // 2) - (h // 2)
            else:
                w = min(w, sw)
                h = min(h, sh)
            
            self.root.geometry(f"{w}x{h}+{x}+{y}")
        except:
            if SystemUtils.IS_MAC: self.root.geometry("1280x850")
            else: self.root.geometry("1024x700")

    @staticmethod
    def center_toplevel(win, parent):
        try:
            win.withdraw() 
            win.update_idletasks() 
            
            pw = parent.winfo_width()
            ph = parent.winfo_height()
            px = parent.winfo_rootx()
            py = parent.winfo_rooty()
            
            cw = win.winfo_width()
            ch = win.winfo_height()
            
            x = px + (pw // 2) - (cw // 2)
            y = py + (ph // 2) - (ch // 2)
            
            win.geometry(f"+{x}+{y}")
            win.deiconify() 
        except: 
            win.deiconify()

    def _build_refine(self):
        tk.Label(self.tab_process, text="Content Refinement (Modifies Files)", font=("Segoe UI",10,"bold")).pack(anchor="w",pady=(10,5),padx=10)
        
        self.chk_frame = tk.Frame(self.tab_process); self.chk_frame.pack(fill="x",padx=10)
        self.chk_vars = {} 
        
        self.f_pdf_ctrl = tk.Frame(self.tab_process)
        tk.Label(self.f_pdf_ctrl, text="PDF Action:", font=("Segoe UI", 9)).pack(anchor="w", padx=10, pady=(10,0))
        self.pdf_mode_var = tk.StringVar(value="No Action")
        self.cb_pdf = ttk.Combobox(self.f_pdf_ctrl, textvariable=self.pdf_mode_var, values=["No Action", "Flatten Only (Fast)", "Flatten + OCR (Slow)"], state="readonly")
        self.cb_pdf.pack(fill="x", padx=10, pady=2)
        
        ctrl = tk.Frame(self.tab_process); ctrl.pack(fill="x",pady=15,padx=10)
        
        tk.Label(ctrl, text="Processing & Preview Quality:").pack(side="left")
        self.dpi_var = tk.StringVar(value="Medium (Standard)")
        self.cb_dpi = ttk.Combobox(ctrl, textvariable=self.dpi_var, values=["Low (Fast)", "Medium (Standard)", "High (Slow)"], width=18, state="readonly")
        self.cb_dpi.pack(side="left",padx=5)
        
        self.btn_prev = self.Btn(ctrl, text="Generate Preview", command=self.safe_preview, state="disabled"); self.btn_prev.pack(side="left",padx=15)
        
        kw_run = {"bg": "#e8f5e9"} if not self.is_mac else {}
        self.btn_run = self.Btn(ctrl, text="Run Refinement", command=self.safe_start_batch, state="disabled", **kw_run); self.btn_run.pack(side="right")

    def _build_export(self):
        tk.Label(self.tab_dist, text="Final Export Strategies", font=("Segoe UI",10,"bold")).pack(anchor="w",pady=10,padx=10)
        f = tk.Frame(self.tab_dist); f.pack(fill="x",padx=10)
        
        tk.Label(f, text="Source Priority:", font=("Segoe UI", 9)).pack(anchor="w", pady=(0,2))
        
        default_prio = CFG.get("default_export_prio")
        self.prio_var = tk.StringVar(value=default_prio)
        self.cb_prio = ttk.Combobox(f, textvariable=self.prio_var, values=["Auto (Best Available)", "Force: OCR (Searchable)", "Force: Flattened (Visual)", "Force: Original Masters"], state="readonly", width=30)
        self.cb_prio.pack(anchor="w", pady=(0,10))
        
        self.var_ext = tk.BooleanVar(); tk.Checkbutton(f, text="Override Source: External Folder", variable=self.var_ext).pack(anchor="w")
        
        f_a = tk.LabelFrame(self.tab_dist, text="Option A: Unique Masters", padx=10, pady=10)
        f_a.pack(fill="x", padx=10, pady=5)
        tk.Label(f_a, text="Export a clean folder containing one copy of every unique file.", justify="left", fg="#555").pack(anchor="w")
        
        ra = tk.Frame(f_a); ra.pack(fill="x", pady=5)
        kw_org = {"bg": "#fff8e1"} if not self.is_mac else {}
        self.btn_org = self.Btn(ra, text="Export Unique Files", command=self.safe_start_organize, state="disabled", **kw_org); self.btn_org.pack(side="right")
        self.btn_dup_rpt = self.Btn(ra, text="View Dup Report", command=self.open_dup_report, state="disabled"); self.btn_dup_rpt.pack(side="right", padx=10)

        f_b = tk.LabelFrame(self.tab_dist, text="Option B: Reconstruct Original Structure", padx=10, pady=10)
        f_b.pack(fill="x", padx=10, pady=5)
        tk.Label(f_b, text="Re-create the original folder structure.", justify="left", fg="#555").pack(anchor="w")
        kw_dist = {"bg": "#fff3e0"} if not self.is_mac else {}
        self.btn_dist = self.Btn(f_b, text="Run Reconstruction", command=self.safe_start_dist, state="disabled", **kw_dist); self.btn_dist.pack(anchor="e", pady=5)

        f_c = tk.LabelFrame(self.tab_dist, text="Option C: Reports & Logs", padx=10, pady=10)
        f_c.pack(fill="x", padx=10, pady=5)
        
        rc = tk.Frame(f_c); rc.pack(fill="x", pady=5)
        self.btn_open_csv = self.Btn(rc, text="Open Full CSV", command=self.open_full_csv, state="disabled"); self.btn_open_csv.pack(side="right", padx=(10,0))
        self.btn_full_csv = self.Btn(rc, text="Export Full Inventory CSV", command=self.safe_start_full_export, state="disabled"); self.btn_full_csv.pack(side="right")
        tk.Label(rc, text="List every single scanned file and its location.", fg="#555").pack(side="left")

    def _build_inspect(self):
        h = tk.Frame(self.tab_inspect); h.pack(fill="x", padx=5, pady=5)
        tk.Label(h, text="Filter:").pack(side="left")
        
        self.search_var = tk.StringVar()
        self.search_var.trace("w", self.filter_inspection)
        self.entry_search = ttk.Entry(h, textvariable=self.search_var)
        self.entry_search.pack(side="left", fill="x", expand=True, padx=5)
        
        tk.Label(self.tab_inspect, text="Double-click a row to open file / view error.", font=("Segoe UI", 8), fg="#666").pack(anchor="w", padx=5)

        f = tk.Frame(self.tab_inspect); f.pack(fill="both",expand=True,padx=5,pady=(0,5))
        self.insp_tree = ttk.Treeview(f, columns=("ID","Name","Status","Copies"), show="headings")
        for c,w in [("ID",60),("Name",200),("Status",80),("Copies",50)]:
            self.insp_tree.heading(c, text=c, command=lambda _c=c: self.sort_tree(self.insp_tree,_c,False)); self.insp_tree.column(c, width=w)
        vsb = ttk.Scrollbar(f, orient="vertical", command=self.insp_tree.yview); self.insp_tree.configure(yscrollcommand=vsb.set)
        self.insp_tree.pack(side="left",fill="both",expand=True); vsb.pack(side="right",fill="y")
        
        self.insp_tree.bind("<Double-1>", self.on_inspect_click)
        
        self.context_menu = Menu(self.root, tearoff=0)
        self.context_menu.add_command(label="Open File", command=self.open_selected_file) 
        self.context_menu.add_command(label="Reveal in Folder", command=self.reveal_in_folder)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="Compare Duplicates...", command=self.on_compare_click)
        
        if self.is_mac:
            self.insp_tree.bind("<Button-2>", self.show_context_menu)
            self.insp_tree.bind("<Control-1>", self.show_context_menu)
        else:
            self.insp_tree.bind("<Button-3>", self.show_context_menu)

    def show_context_menu(self, event):
        try:
            item = self.insp_tree.identify_row(event.y)
            if item:
                self.insp_tree.selection_set(item)
                self.context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self.context_menu.grab_release()

    def open_selected_file(self):
        item_id = self.insp_tree.selection()
        if not item_id: return
        self.on_inspect_click(None)

    def reveal_in_folder(self):
        ws = self.get_ws()
        if not ws: return
        item_id = self.insp_tree.selection()
        if not item_id: return
        
        # CHANGED: Look up by ID (Col 0) instead of Name (Col 1) for safety
        file_id = self.insp_tree.item(item_id[0], 'values')[0] 
        
        data = next((v for k,v in self.current_manifest.items() if v.get('id') == file_id), None)
        
        if data:
            path = ws/"01_Master_Files"/data['uid']
            if path.exists(): 
                SystemUtils.reveal_file(path)
            else:
                messagebox.showwarning("File Missing", f"Could not find master file at:\n{path}")
        else:
             messagebox.showerror("Error", "Could not locate file in manifest.")

    def on_compare_click(self):
        ws = self.get_ws()
        item_id = self.insp_tree.selection()
        if not ws or not item_id: return
        
        name = self.insp_tree.item(item_id[0], 'values')[1]
        data = next((v for k,v in self.current_manifest.items() if v.get('name') == name), None)
        
        if not data or len(data.get('copies', [])) < 2:
            messagebox.showinfo("Compare", "No duplicates to compare.")
            return
            
        master_file = ws/"01_Master_Files"/data['uid']
        
        root = data.get('root')
        if not root or not Path(root).exists():
            root = filedialog.askdirectory(title=f"Locate Source Folder for {name}")
            if not root: return
        
        duplicates = []
        for c in data['copies']:
            if c != data['master']:
                path = Path(root) / c
                if path.exists(): duplicates.append(path)
        
        if duplicates:
            ForensicComparator(self.root, ws, self.current_manifest, master_file, duplicates)
        else:
            messagebox.showerror("Error", "Could not locate any duplicate files.")

    def open_settings(self):
        win = tk.Toplevel(self.root)
        win.title("Preferences")
        win.geometry("600x700")
        
        App.center_toplevel(win, self.root)
        
        lf_perf = tk.LabelFrame(win, text="Processing Engine", padx=10, pady=10)
        lf_perf.pack(fill="x", padx=10, pady=5)
        
        tk.Label(lf_perf, text="Max Worker Threads (0 = Auto):", font=("Segoe UI", 9, "bold")).grid(row=0,column=0,sticky="w")
        v_threads = tk.IntVar(value=CFG.get("max_threads"))
        tk.Spinbox(lf_perf, from_=0, to=32, textvariable=v_threads, width=5).grid(row=0,column=1,sticky="e")
        
        tk.Label(lf_perf, text="Safety Cap (Max Pixels):", font=("Segoe UI", 9, "bold")).grid(row=2,column=0,sticky="w", pady=(10,0))
        v_pixels = tk.StringVar(value=str(CFG.get("max_pixels")))
        tk.Entry(lf_perf, textvariable=v_pixels, width=15).grid(row=2,column=1,sticky="e", pady=(10,0))

        lf_def = tk.LabelFrame(win, text="Workflow Defaults", padx=10, pady=10)
        lf_def.pack(fill="x", padx=10, pady=5)
        
        tk.Label(lf_def, text="Default Ingest Mode:", font=("Segoe UI", 9, "bold")).grid(row=0,column=0,sticky="w")
        v_ingest = tk.StringVar(value=CFG.get("default_ingest_mode"))
        ttk.Combobox(lf_def, textvariable=v_ingest, values=["Standard", "Lightning", "Deep"], state="readonly").grid(row=0,column=1,sticky="e")

        tk.Label(lf_def, text="Default Export Priority:", font=("Segoe UI", 9, "bold")).grid(row=2,column=0,sticky="w", pady=(10,0))
        v_export = tk.StringVar(value=CFG.get("default_export_prio"))
        ttk.Combobox(lf_def, textvariable=v_export, values=["Auto (Best Available)", "Force: OCR (Searchable)", "Force: Flattened (Visual)", "Force: Original Masters"], state="readonly", width=30).grid(row=2,column=1,sticky="e", pady=(10,0))

        lf_ocr = tk.LabelFrame(win, text="Optical Character Recognition (OCR)", padx=10, pady=10)
        lf_ocr.pack(fill="x", padx=10, pady=5)
        
        tk.Label(lf_ocr, text="Tesseract Language:", font=("Segoe UI", 9, "bold")).grid(row=0,column=0,sticky="w")
        langs = get_tesseract_langs()
        v_lang = tk.StringVar(value=CFG.get("ocr_lang"))
        
        current = v_lang.get()
        if "(" not in current and current in langs: pass 
        else: 
            match = next((l for l in langs if f"({current})" in l), None)
            if match: v_lang.set(match)
            
        ttk.Combobox(lf_ocr, textvariable=v_lang, values=langs, state="readonly").grid(row=0,column=1,sticky="e")
        
        fr_btns = tk.Frame(lf_ocr)
        fr_btns.grid(row=1, column=0, columnspan=2, pady=10, sticky="e")
        
        def open_lang_folder():
            path = os.environ.get("TESSDATA_PREFIX")
            if not path and HAS_TESSERACT:
                try: path = str(Path(pytesseract.pytesseract.tesseract_cmd).parent / "tessdata")
                except: path = None
            if path and Path(path).exists(): SystemUtils.open_file(path)
            else: messagebox.showerror("Error", "Could not locate tessdata folder automatically.")

        def open_help():
            webbrowser.open("https://github.com/tesseract-ocr/tessdata_best")

        self.Btn(fr_btns, text="Open Language Folder", command=open_lang_folder).pack(side="left", padx=5)
        self.Btn(fr_btns, text="Get Languages (Web)", command=open_help).pack(side="left", padx=5)

        lf_support = tk.LabelFrame(win, text="Support & Diagnostics", padx=10, pady=10)
        lf_support.pack(fill="x", padx=10, pady=5)
        
        def do_export_debug():
            self.start_debug_export_thread(btn_export, win)

        btn_export = self.Btn(lf_support, text="Export Debug Bundle (Zipped Logs)", command=do_export_debug)
        btn_export.pack(fill="x", pady=2)
        
        # --- DOCUMENTATION BUTTONS ---
        f_docs = tk.Frame(lf_support); f_docs.pack(fill="x", pady=5)
        self.Btn(f_docs, text="View Changelog", command=lambda: DocViewer(win, "CHANGELOG.md", "Version History")).pack(side="left", fill="x", expand=True, padx=(0,5))
        self.Btn(f_docs, text="View User Guide", command=lambda: DocViewer(win, "README.md", "User Guide")).pack(side="left", fill="x", expand=True, padx=(5,0))

        def save():
            CFG.set("max_threads", v_threads.get())
            try: 
                px_val = int(v_pixels.get())
                if px_val <= 0: raise ValueError
                CFG.set("max_pixels", px_val)
            except: 
                 CFG.set("max_pixels", 500000000)
            
            CFG.set("default_ingest_mode", v_ingest.get())
            CFG.set("default_export_prio", v_export.get())
            
            code = parse_lang_code(v_lang.get())
            CFG.set("ocr_lang", code)
            
            Image.MAX_IMAGE_PIXELS = int(CFG.get("max_pixels"))
            self.prio_var.set(v_export.get())
            messagebox.showinfo("Saved", "Preferences updated.")
            win.destroy()
            
        btn_fr = tk.Frame(win); btn_fr.pack(pady=20)
        self.Btn(btn_fr, text="Save & Close", command=save, bg="#e8f5e9").pack(side="left", padx=10)

    def start_debug_export_thread(self, btn_ref, win_ref):
        def _run():
            ws = self.get_ws()
            # Capture the path as a string safely on the main thread
            ws_str = str(ws) if ws else None
            # Delegate to worker without touching UI
            self.worker.run_debug_export(ws_str)
            self.q.put(("export_reset_btn", btn_ref))
        
        btn_ref.config(text="Exporting...", state="disabled")
        threading.Thread(target=_run, daemon=True).start()

    def on_close(self):
        try:
            CFG.set("last_geometry", self.root.geometry())
            ws = self.get_ws()
            if ws: CFG.set("last_workspace", str(ws))
            current_tab = self.nb.index(self.nb.select())
            CFG.set("last_tab", current_tab)
        except: pass
        self.root.destroy()
        
    def restore_session(self):
        try:
            last_ws = CFG.get("last_workspace")
            if last_ws:
                for item in self.tree.get_children():
                    val = self.tree.item(item)['values'][0]
                    if Path(last_ws).name == val:
                        self.tree.selection_set(item)
                        self.tree.see(item)
                        break
            tab_idx = CFG.get("last_tab")
            if tab_idx is not None and tab_idx < 3: self.nb.select(tab_idx)
        except: pass

    def open_receipt(self):
        ws = self.get_ws()
        if not ws: return
        rpt_dir = ws / "04_Reports"
        if rpt_dir.exists():
            files = sorted(rpt_dir.glob("*.html"), key=os.path.getmtime, reverse=True)
            if files: SystemUtils.open_file(files[0])
            else: messagebox.showinfo("No Receipt", "No job receipt found yet.")
        else: messagebox.showinfo("No Receipt", "No job receipt found.")

    def open_dup_report(self):
        ws = self.get_ws()
        if not ws: return
        p = ws / "03_Organized_Output" / "duplicates_report.csv"
        if p.exists(): SystemUtils.open_file(p)
        else: messagebox.showinfo("Not Found", "No duplicates report found.")

    def open_full_csv(self):
        ws = self.get_ws()
        if not ws: return
        p = ws / "04_Reports" / "Full_Inventory_Manifest.csv"
        if p.exists(): SystemUtils.open_file(p)
        else: messagebox.showinfo("Not Found", "CSV not generated yet.")

    def filter_inspection(self, *args):
        query = self.search_var.get().lower()
        self.insp_tree.delete(*self.insp_tree.get_children())
        for k, v in self.current_manifest.items():
            name = v.get('name', '').lower()
            uid = v.get('id', '').lower()
            if query in name or query in uid:
                self._insert_inspect_row(v)

    def _insert_inspect_row(self, v):
        if v.get("status") == "QUARANTINE":
            st = "‚õî Quarantined"
            self.insp_tree.insert("", "end", values=("Q", v.get('orig_name', v.get('name','?')), st, "-"), tags=('q',))
        else:
            st = "Duplicate" if len(v.get('copies',[]))>1 else "Master"
            self.insp_tree.insert("", "end", values=(v.get('id','?'), v.get('name','?'), st, len(v.get('copies',[]))), tags=('ok',))

    def on_inspect_click(self, event):
        item_id = self.insp_tree.selection()
        if not item_id: return
        vals = self.insp_tree.item(item_id[0], 'values')
        name = vals[1]
        data = next((v for k,v in self.current_manifest.items() if v.get('name') == name or v.get('orig_name') == name), None)
        if not data: return
        ws = self.get_ws()
        if not ws: return
        if data.get("status") == "QUARANTINE":
            reason = data.get('error_reason', 'Unknown Error')
            messagebox.showerror("Quarantine Info", f"File: {name}\nReason: {reason}")
            q_file = next((f for f in (ws/"00_Quarantine").iterdir() if name in f.name), None)
            if q_file: SystemUtils.open_file(q_file.parent)
        else:
            f_path = ws/"01_Master_Files"/data['uid']
            if f_path.exists():
                 SystemUtils.open_file(f_path)

    def check_run_btn(self, *args):
        if self.running: 
            self.btn_run.config(state="disabled")
            return
            
        any_checked = any(v.get() for v in self.chk_vars.values())
        pdf_active = self.pdf_mode_var.get() != "No Action"
        self.btn_run.config(state="normal" if (any_checked or pdf_active) else "disabled")

    def check_updates(self, manual=False):
        try:
            base_url = SystemUtils.UPDATE_MANIFEST_URL
            if "REPLACE" in base_url:
                if manual: messagebox.showinfo("Update Check", "Update URL not configured.")
                return
            url = f"{base_url}?t={int(time.time())}" if "?" not in base_url else f"{base_url}&t={int(time.time())}"
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            with urllib.request.urlopen(url, context=ctx, timeout=5) as r:
                if r.status == 200:
                    data = json.loads(r.read().decode())
                    rem_ver = data.get("latest_version", "v0")
                    if rem_ver > SystemUtils.CURRENT_VERSION:
                        self.q.put(("update_avail", rem_ver, data.get("download_url")))
                    elif manual:
                         messagebox.showinfo("Update Check", f"You are up to date ({SystemUtils.CURRENT_VERSION}).")
        except Exception as e: 
            if manual: messagebox.showerror("Update Check Failed", str(e))

    def ask_ingest_mode(self):
        top = tk.Toplevel(self.root)
        top.title("New Job Setup")
        top.geometry("450x500") 
        
        App.center_toplevel(top, self.root)
        
        tk.Label(top, text="Select Mode", font=("Segoe UI", 12, "bold")).pack(pady=15)
        
        mode = tk.StringVar(value=CFG.get("default_ingest_mode"))
        modes = [
            ("Standard (Recommended)", "Smart Text Hash (PDFs).\nStrict Binary Hash (Others)."),
            ("Lightning (Fastest)", "Strict Binary Hash (All Files).\nExact digital copies only."),
            ("Deep Scan (Slowest)", "Full Text Scan (PDFs).\nStrict Binary Hash (Others).")
        ]
        for m, desc in modes:
            f = tk.Frame(top, pady=10, relief="groove", bd=1); f.pack(fill="x", padx=20, pady=5)
            tk.Radiobutton(f, text=m, variable=mode, value=m.split(" ")[0], font=("Segoe UI", 10, "bold")).pack(anchor="w", padx=5)
            tk.Label(f, text=desc, fg="#555", justify="left").pack(anchor="w", padx=25)
        
        def go():
            # new_id = uuid.uuid4() # (Unused, clean removal)
            top.destroy(); d = filedialog.askdirectory()
            if d: 
                self.toggle(False)
                threading.Thread(target=self.wrap, args=(self.worker.run_inventory, d, mode.get()), daemon=True).start()
        
        self.Btn(top, text="Select Folder & Start", command=go).pack(fill="x", padx=20, pady=20, side="bottom")

    def toggle(self, enable, reset=True):
        self.running = not enable; s = "normal" if enable else "disabled"
        if not enable: self.start_t = time.time(); self.paused = False
        self.tree.config(selectmode="browse" if enable else "none")
        for c in [self.btn_new, self.btn_refresh, self.btn_del, self.btn_dist, self.btn_prev, self.btn_open, self.btn_org, self.btn_full_csv, self.btn_open_csv]: 
            try: c.configure(state=s) 
            except: pass
        if enable: self.check_run_btn() 
        else: self.btn_run.config(state="disabled")
        self.btn_stop.config(state="normal" if not enable else "disabled")
        self.btn_pause.config(state="normal" if not enable else "disabled")
        if enable and reset: self.on_sel(None)

    def stop(self):
        if messagebox.askyesno("Confirm Stop", "Stopping now will abort the current operation completely.\nYou will need to restart the job.\n\nAre you sure?"):
            self.worker.stop()
            self.btn_stop.config(state="disabled")
            self.btn_pause.config(state="disabled")

    def toggle_pause(self):
        if self.paused:
            self.worker.resume()
            if not self.is_mac: self.btn_pause.config(text="PAUSE", bg="SystemButtonFace")
            else: self.btn_pause.config(text="PAUSE")
            self.lbl_status.config(text="Resuming...", fg="blue")
        else:
            self.worker.pause()
            if not self.is_mac: self.btn_pause.config(text="RESUME", bg="yellow")
            else: self.btn_pause.config(text="RESUME")
        self.paused = not self.paused

    def load_jobs(self, sel=None):
        self.tree.delete(*self.tree.get_children())
        try: items = sorted(WORKSPACES_ROOT.iterdir(), key=lambda x: x.stat().st_mtime, reverse=True)
        except: items = []
        for d in items:
            if d.is_dir():
                s = "Empty"
                if (d/"status.json").exists(): 
                     with open(d/"status.json") as f: s = json.load(f).get("stage","?")
                elif (d/"Final_Delivery").exists(): s = "DISTRIBUTED"
                elif (d/"03_Organized_Output").exists(): s = "ORGANIZED"
                elif (d/"02_Ready_For_Redistribution").exists(): s = "PROCESSED"
                elif (d/"01_Master_Files").exists(): s = "INGESTED"
                
                item_id = self.tree.insert("", "end", values=(d.name, s, datetime.fromtimestamp(d.stat().st_mtime).strftime('%Y-%m-%d %H:%M')))
                
                if sel and str(d) == str(Path(sel)):
                     self.tree.selection_set(item_id)
                     self.tree.see(item_id)

    def safe_start_batch(self):
        ws = self.get_ws()
        opts = {k: v.get() for k,v in self.chk_vars.items()}
        
        p_mode = self.pdf_mode_var.get()
        if "OCR" in p_mode: opts['pdf_mode'] = 'ocr'
        elif "Flatten" in p_mode: opts['pdf_mode'] = 'flatten'
        else: opts['pdf_mode'] = 'none'
        
        d_raw = self.dpi_var.get()
        if "Low" in d_raw: opts['dpi'] = 150
        elif "High" in d_raw: opts['dpi'] = 600
        else: opts['dpi'] = 300
        
        if ws: self.toggle(False); threading.Thread(target=self.wrap, args=(self.worker.run_batch, str(ws), opts), daemon=True).start()

    def safe_start_organize(self):
        ws = self.get_ws()
        prio = self.prio_var.get()
        if ws: self.toggle(False); threading.Thread(target=self.wrap, args=(self.worker.run_organize, str(ws), prio), daemon=True).start()
        
    def safe_start_dist(self):
        ws=self.get_ws(); src=filedialog.askdirectory() if self.var_ext.get() else None
        prio = self.prio_var.get()
        if ws: self.toggle(False); threading.Thread(target=self.wrap, args=(self.worker.run_distribute, str(ws), src, prio), daemon=True).start()

    def safe_start_full_export(self):
        ws = self.get_ws()
        if ws: self.toggle(False); threading.Thread(target=self.wrap, args=(self.worker.run_full_export, str(ws)), daemon=True).start()
        
    def safe_preview(self):
        ws=self.get_ws()
        d_raw = self.dpi_var.get()
        dpi = 150 if "Low" in d_raw else (600 if "High" in d_raw else 300)
        if ws: self.toggle(False); threading.Thread(target=self.wrap, args=(self.worker.run_preview, str(ws), dpi), daemon=True).start()
    
    def safe_delete_job(self):
        ws = self.get_ws()
        if ws and messagebox.askyesno("Confirm", "Delete Job?"):
            def _del():
                try: shutil.rmtree(ws)
                except Exception as e: self.q.put(("error", f"Could not delete: {e}"))
                finally: self.q.put(("job", None))
            threading.Thread(target=_del, daemon=True).start()

    def on_sel(self, e):
        for w in self.chk_frame.winfo_children(): w.destroy()
        self.chk_vars.clear()
        self.btn_run.config(state="disabled")
        self.btn_prev.config(state="disabled")
        self.cb_dpi.config(state="disabled")
        self.cb_pdf.config(state="disabled")
        self.lbl_stats.config(text="Stats: Select a job...")
        self.btn_receipt.config(state="disabled")
        
        self.dpi_var.set("Medium (Standard)")
        self.pdf_mode_var.set("No Action")
        
        self.btn_dist.config(state="disabled")
        self.btn_org.config(state="disabled")
        self.btn_dup_rpt.config(state="disabled")
        
        self.btn_full_csv.config(state="disabled")
        self.btn_open_csv.config(state="disabled")
        
        self.current_manifest = {}
        self.insp_tree.delete(*self.insp_tree.get_children())
        self.search_var.set("")

        if self.running: return
        ws = self.get_ws()
        
        if not ws: 
            self.btn_open.config(state="disabled")
            return
        
        self.btn_open.config(state="normal")
        self.btn_dist.config(state="normal")
        self.btn_org.config(state="normal")
        self.btn_full_csv.config(state="normal")
        
        if (ws/"04_Reports").exists():
            if list((ws/"04_Reports").glob("Audit_Certificate_*.html")):
                self.btn_receipt.config(state="normal")
            if (ws/"04_Reports"/"Full_Inventory_Manifest.csv").exists():
                self.btn_open_csv.config(state="normal")
            
        if (ws/"03_Organized_Output"/"duplicates_report.csv").exists():
            self.btn_dup_rpt.config(state="normal")

        try:
            with open(ws/"stats.json") as f: s = json.load(f)
            total_seconds = int(
                s.get('ingest_time',0) + 
                s.get('batch_time',0) + 
                s.get('dist_time',0) + 
                s.get('organize_time',0)
            )
            self.lbl_stats.config(text=f"Files: {s.get('total_scanned',0)} | Masters: {s.get('masters',0)} | Q: {s.get('quarantined',0)} | Time: {str(timedelta(seconds=total_seconds))}")
        except: self.lbl_stats.config(text="Stats: N/A")
        
        types = set()
        if (ws/"01_Master_Files").exists(): types = {f.suffix.lower() for f in (ws/"01_Master_Files").rglob('*') if f.is_file()}
        
        def ac(l,k,desc): 
            f = tk.Frame(self.chk_frame); f.pack(fill="x", pady=2)
            v=tk.BooleanVar(); v.trace_add("write", self.check_run_btn)
            c=tk.Checkbutton(f,text=l,variable=v, font=("Segoe UI", 9, "bold")); c.pack(anchor="w")
            tk.Label(f, text=desc, font=("Segoe UI", 8), fg="#555").pack(anchor="w", padx=20)
            self.chk_vars[k]=v
        
        if '.pdf' in types: 
             self.f_pdf_ctrl.pack(fill="x", padx=10, pady=2) # Show
             self.cb_pdf.config(state="readonly")
             self.pdf_mode_var.trace_add("write", self.check_run_btn)
             self.btn_prev.config(state="normal")
        else:
             self.f_pdf_ctrl.pack_forget() 

        if any(x in types for x in ['.jpg','.png']): ac("Resize Images","resize","Resize to 1920px (HD Standard)."); ac("Images to PDF","img2pdf","Bundle loose images into one PDF.")
        if any(x in types for x in ['.docx','.xlsx']): ac("Sanitize Office","sanitize","Remove author metadata and revision history.")
        
        if types:
             self.cb_dpi.config(state="readonly")
        
        self.log_box.delete(1.0, tk.END)
        if (ws/"session_log.txt").exists(): self.log_box.insert(tk.END, (ws/"session_log.txt").read_text(encoding="utf-8"))
        
        if (ws/"manifest.json").exists():
            try:
                with open(ws/"manifest.json") as f:
                    self.current_manifest = json.load(f)
                    for k,v in self.current_manifest.items():
                        self._insert_inspect_row(v)
            except: pass

    def sort_tree(self, t, c, r):
        l = [(t.set(k,c),k) for k in t.get_children('')]
        try: l.sort(key=lambda x: int(x[0]), reverse=r)
        except: l.sort(reverse=r)
        for i, (_,k) in enumerate(l): t.move(k,'',i)
        t.heading(c, command=lambda: self.sort_tree(t,c,not r))

    def open_app_log(self): SystemUtils.open_file(LOG_PATH)
    def open_f(self): SystemUtils.open_file(self.get_ws())
    def get_ws(self): s = self.tree.selection(); return WORKSPACES_ROOT / self.tree.item(s[0])['values'][0] if s else None
    def wrap(self, func, *args):
        try: func(*args)
        except Exception as e: self.q.put(("error", str(e))); self.q.put(("done",))
    def poll(self):
        try:
            for _ in range(20):
                if self.q.empty(): break
                m = self.q.get_nowait()
                if m[0]=='log': self.log_box.insert(tk.END, m[1]+"\n"); self.log_box.see(tk.END)
                elif m[0]=='main_p': self.p_main.set(m[1]); self.lbl_status.config(text=m[2], fg="blue")
                elif m[0]=='status_blue': self.lbl_status.config(text=m[1], fg="blue")
                elif m[0]=='status': self.lbl_status.config(text=m[1], fg="orange")
                elif m[0]=='job': self.load_jobs(m[1]) 
                elif m[0]=='done': 
                    self.toggle(True); 
                    self.lbl_status.config(text="Done", fg="green"); 
                    self.btn_pause.config(text="PAUSE", bg="SystemButtonFace", state="disabled")
                elif m[0]=='preview_done':
                    self.toggle(True, reset=False) 
                    self.lbl_status.config(text="Preview Ready", fg="green")
                elif m[0]=='update_avail':
                    if messagebox.askyesno("Update Available", f"Version {m[1]} is available.\nDownload now?"): webbrowser.open(m[2])
                elif m[0]=='auto_open': SystemUtils.open_file(m[1])
                elif m[0]=='error': messagebox.showerror("Error", m[1])
                elif m[0]=='slot_config':
                    count = m[1]
                    for w in self.frame_slots.winfo_children(): w.destroy()
                    self.slot_widgets = {}
                    self.slot_frames = []
                    for i in range(count):
                        f = tk.Frame(self.frame_slots, relief="sunken", bd=1, bg="white")
                        f.pack(fill="x", padx=5, pady=1)
                        self.slot_frames.append(f)
                        tk.Label(f, text=f"Worker {i+1}:", font=("Consolas", 8), bg="#eee", width=10).pack(side="left")
                        lbl = tk.Label(f, text="Idle", font=("Segoe UI", 8), anchor="w", bg="white")
                        lbl.pack(side="left", fill="x", expand=True)
                elif m[0]=='slot_update':
                    tid, txt, _ = m[1], m[2], m[3]
                    if tid not in self.slot_widgets:
                        idx = len(self.slot_widgets)
                        if idx < len(self.slot_frames):
                             lbl = self.slot_frames[idx].winfo_children()[1]
                             self.slot_widgets[tid] = lbl
                    if tid in self.slot_widgets:
                        self.slot_widgets[tid].config(text=txt)
                elif m[0]=='export_success':
                    messagebox.showinfo("Export Successful", f"Debug bundle saved to:\n{Path(m[1]).name}")
                    SystemUtils.open_file(Path(m[1]).parent)
                elif m[0]=='export_reset_btn':
                    try: m[1].config(text="Export Debug Bundle (Zipped Logs)", state="normal")
                    except: pass

        except: pass
        if self.running and not self.paused: self.lbl_timer.config(text=str(timedelta(seconds=int(time.time()-self.start_t))))
        self.root.after(100, self.poll)
==================== END FILE: docrefine\gui\app.py ====================


==================== START FILE: docrefine\gui\app_qt.py ====================
import sys
import threading
import shutil
import ctypes
from pathlib import Path
from PySide6.QtWidgets import QApplication, QMessageBox, QFileDialog
from PySide6.QtCore import Qt
from .main_window import MainWindow
from .dialogs import NewJobDialog, SettingsDialog, InternalViewerDialog
from .qt_adapter import DocRefineAdapter
from .forensic import ForensicDialog
from docrefine.worker import Worker
from docrefine.config import log_app, LOG_PATH, WORKSPACES_ROOT, SystemUtils

def run():
    app = QApplication(sys.argv)
    app.setStyle("Fusion") 
    
    window = MainWindow()
    adapter = DocRefineAdapter()
    worker = Worker(callback=adapter.ingest_event)
    
    # --- UI UPDATES ---
    adapter.sig_log.connect(window.update_log)
    adapter.sig_progress_main.connect(window.update_progress)
    adapter.sig_status.connect(lambda s, m, c: window.update_status_label(s, m, c))
    
    def on_done():
        window.set_processing_state(False)
        window.refresh_job_list(get_selected_ws())
    adapter.sig_done.connect(on_done)
    
    def on_job_data(path_str):
        window.refresh_job_list(auto_select_path=path_str)
    adapter.sig_job_data.connect(on_job_data)
    
    adapter.sig_worker_config.connect(window.setup_slots)
    adapter.sig_slot_update.connect(window.update_slot)
    
    def handle_notification(data):
        if data['title'] == "Preview Ready":
             SystemUtils.open_file(data['open_path'])
        else:
             QMessageBox.information(window, data['title'], data['msg'])
             if 'open_path' in data: SystemUtils.open_file(data['open_path'])
    adapter.sig_notification.connect(handle_notification)

    # --- BUTTONS ---
    window.btn_stop.clicked.connect(worker.stop)
    
    def toggle_pause(checked):
        if checked: 
            worker.log("Pausing operation...")
            worker.pause()
            window.pause_timer(True)
            window.btn_pause.setText("Resume")
        else: 
            worker.log("Resuming operation...")
            worker.resume()
            window.pause_timer(False)
            window.btn_pause.setText("Pause")
    window.btn_pause.clicked.connect(toggle_pause)

    # --- FORENSIC ---
    def start_forensic(file_id):
        ws = window.job_tree.selectedItems()[0].data(0, Qt.UserRole)
        ws_path = Path(ws)
        entry = None
        for k, v in window.current_manifest.items():
            if v.get('id') == file_id: entry = v; break
        
        if not entry: return
        master = ws_path / "01_Master_Files" / entry['uid']
        dups = []
        if 'root' in entry:
            root = Path(entry['root'])
            for copy_rel in entry.get('copies', []):
                if copy_rel != entry.get('master'):
                    d_path = root / copy_rel
                    if d_path.exists(): dups.append(d_path)
        
        if not dups:
            QMessageBox.information(window, "Info", "No duplicates accessible.")
            return
        
        ForensicDialog(ws_path, window.current_manifest, master, dups, window).exec()

    window.req_compare.connect(start_forensic)

    # --- ACTIONS ---
    def get_selected_ws():
        items = window.job_tree.selectedItems()
        return str(items[0].data(0, Qt.UserRole)) if items else None

    window.btn_delete.clicked.connect(lambda: delete_job(get_selected_ws()))
    window.btn_open_folder.clicked.connect(lambda: SystemUtils.open_file(get_selected_ws()))
    
    def delete_job(ws):
        if not ws: return
        if QMessageBox.question(window, "Confirm", "Delete this job?") == QMessageBox.Yes:
            try: shutil.rmtree(ws)
            except: pass
            window.refresh_job_list(None)

    def open_receipt():
        ws = Path(get_selected_ws())
        rpt = list((ws/"04_Reports").glob("*.html"))
        if rpt: SystemUtils.open_file(rpt[0])
    window.btn_receipt.clicked.connect(open_receipt)

    window.btn_logs.clicked.connect(lambda: InternalViewerDialog("Log", Path(LOG_PATH).read_text(encoding='utf-8', errors='ignore'), window).exec())
    
    def open_settings():
        dlg = SettingsDialog(window)
        dlg.btn_cl.clicked.disconnect()
        dlg.btn_ug.clicked.disconnect()
        def view_doc(f): 
            p = SystemUtils.find_doc_file(f)
            if p: InternalViewerDialog(f, p.read_text(encoding='utf-8', errors='ignore'), window).exec()
        dlg.btn_cl.clicked.connect(lambda: view_doc("CHANGELOG.md"))
        dlg.btn_ug.clicked.connect(lambda: view_doc("README.md"))
        dlg.btn_export_debug.clicked.disconnect()
        dlg.btn_export_debug.clicked.connect(lambda: threading.Thread(target=worker.run_debug_export, args=(get_selected_ws(),), daemon=True).start())
        dlg.exec()
    
    window.btn_settings.clicked.connect(open_settings)

    def resolve_file_path(file_id):
        ws = get_selected_ws()
        if not ws: return None, "No job"
        target = None
        for k, v in window.current_manifest.items():
            if v.get('id') == file_id: target = v; break
        if not target: return None, "ID not found"
        return Path(ws) / "01_Master_Files" / target['uid'], "OK"

    def on_inspector_open(file_id):
        p, err = resolve_file_path(file_id)
        if p and p.exists(): SystemUtils.open_file(p)
        else: QMessageBox.warning(window, "Error", f"File missing: {err}")

    def on_inspector_reveal(file_id):
        p, err = resolve_file_path(file_id)
        if p:
            clean = str(p.resolve())
            if SystemUtils.IS_WIN:
                # FIX: Use ShellExecute to bypass SW_HIDE patch
                # 1 = SW_SHOWNORMAL
                ctypes.windll.shell32.ShellExecuteW(None, "open", "explorer.exe", f'/select,"{clean}"', None, 1)
            else:
                SystemUtils.reveal_file(clean)

    window.req_open_file.connect(on_inspector_open)
    window.req_reveal_file.connect(on_inspector_reveal)
    window.insp_tree.itemDoubleClicked.connect(lambda item, _: on_inspector_open(item.text(0)))

    # --- PROCESS START ---
    def start_process(target, args, multi_threaded=False):
        window.set_processing_state(True, multi_threaded=multi_threaded)
        threading.Thread(target=target, args=args, daemon=True).start()

    def launch_new_job():
        d = NewJobDialog(window)
        if d.exec():
            start_process(worker.run_inventory, (d.selected_path, d.selected_mode), multi_threaded=False)
    window.btn_new_job.clicked.connect(launch_new_job)

    def launch_refine():
        ws = get_selected_ws()
        if not ws: return
        opts = {
            "resize": window.chk_resize.isChecked(),
            "img2pdf": window.chk_img2pdf.isChecked(),
            "sanitize": window.chk_sanitize.isChecked(),
            "pdf_mode": ['none','flatten','ocr'][window.cb_pdf_mode.currentIndex()],
            "dpi": [150, 300, 600][window.cb_dpi.currentIndex()]
        }
        start_process(worker.run_batch, (ws, opts), multi_threaded=True)
    window.btn_run_refine.clicked.connect(launch_refine)
    
    window.btn_preview.clicked.connect(lambda: start_process(worker.run_preview, (get_selected_ws(), [150,300,600][window.cb_dpi.currentIndex()])))
    window.btn_org.clicked.connect(lambda: start_process(worker.run_organize, (get_selected_ws(), window.cb_prio.currentText())))
    window.btn_dist.clicked.connect(lambda: start_process(worker.run_distribute, (get_selected_ws(), None, window.cb_prio.currentText())))
    window.btn_csv.clicked.connect(lambda: start_process(worker.run_full_export, (get_selected_ws(),)))

    window.refresh_job_list()
    window.show()
    sys.exit(app.exec())
==================== END FILE: docrefine\gui\app_qt.py ====================


==================== START FILE: docrefine\gui\dialogs.py ====================
import os
import sys
import webbrowser
from pathlib import Path
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QRadioButton, 
    QButtonGroup, QPushButton, QFileDialog, QFrame,
    QSpinBox, QComboBox, QGroupBox, QGridLayout, QLineEdit,
    QHBoxLayout, QMessageBox, QWidget, QTextEdit, QDialogButtonBox
)
from PySide6.QtCore import Qt, QSize
from PySide6.QtGui import QFont, QColor, QPalette
from docrefine.config import CFG, SystemUtils

# --- HELPER: Tesseract ---
def get_tesseract_langs():
    try:
        import pytesseract
        raw_langs = pytesseract.get_languages(config='')
        friendly_map = {
            'eng': 'English', 'spa': 'Spanish', 'fra': 'French', 'deu': 'German',
            'ita': 'Italian', 'por': 'Portuguese', 'chi_sim': 'Chinese (Simp)',
            'jpn': 'Japanese', 'rus': 'Russian'
        }
        clean = []
        for l in raw_langs:
            if l == 'osd': continue
            name = friendly_map.get(l, l)
            if name != l: clean.append(f"{name} ({l})")
            else: clean.append(l)
        return sorted(clean)
    except: return ["eng"]

# --- DIALOGS ---

class InternalViewerDialog(QDialog):
    """Generic Read-Only Text Viewer for Docs/Logs"""
    def __init__(self, title, content, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.resize(800, 600)
        
        layout = QVBoxLayout(self)
        
        self.txt = QTextEdit()
        self.txt.setReadOnly(True)
        self.txt.setPlainText(content)
        # Set a monospaced font for logs/markdown
        font = QFont("Consolas", 10)
        font.setStyleHint(QFont.Monospace)
        self.txt.setFont(font)
        
        layout.addWidget(self.txt)
        
        btns = QDialogButtonBox(QDialogButtonBox.Close)
        btns.rejected.connect(self.close)
        layout.addWidget(btns)

class NewJobDialog(QDialog):
    def __init__(self, parent=None, default_mode="Standard"):
        super().__init__(parent)
        self.setWindowTitle("New Job Setup")
        self.resize(450, 450)
        self.selected_mode = default_mode
        self.selected_path = None
        
        layout = QVBoxLayout(self)
        lbl = QLabel("Select Ingest Mode")
        lbl.setStyleSheet("font-weight: bold; font-size: 11pt;")
        layout.addWidget(lbl)
        
        self.bg = QButtonGroup(self)
        self.modes = [
            ("Standard (Recommended)", "Smart Text Hash (PDFs).\nStrict Binary Hash (Others).", "Standard"),
            ("Lightning (Fastest)", "Strict Binary Hash (All Files).\nExact digital copies only.", "Lightning"),
            ("Deep Scan (Slowest)", "Full Text Scan (PDFs).\nStrict Binary Hash (Others).", "Deep")
        ]
        
        for text, desc, val in self.modes:
            frame = QFrame()
            frame.setFrameShape(QFrame.StyledPanel)
            fl = QVBoxLayout(frame)
            fl.setSpacing(2)
            rb = QRadioButton(text)
            if val == default_mode: rb.setChecked(True)
            fl.addWidget(rb)
            self.bg.addButton(rb)
            lbl_d = QLabel(desc)
            # Use standard palette color for description instead of hardcoded grey
            lbl_d.setStyleSheet("margin-left: 20px; font-size: 9pt;")
            # Manually dim it slightly if needed, or rely on opacity
            opacity_eff = QPalette()
            opacity_eff.setColor(QPalette.WindowText, QColor(128, 128, 128))
            
            fl.addWidget(lbl_d)
            layout.addWidget(frame)
            rb.mode_value = val

        layout.addStretch()
        btn = QPushButton("Select Folder && Start") # && escapes to &
        btn.setStyleSheet("padding: 8px; font-weight: bold;")
        btn.clicked.connect(self.on_submit)
        layout.addWidget(btn)

    def on_submit(self):
        self.selected_mode = self.bg.checkedButton().mode_value
        d = QFileDialog.getExistingDirectory(self, "Select Source Folder")
        if d:
            self.selected_path = d
            self.accept()

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Preferences")
        self.resize(600, 650)
        
        layout = QVBoxLayout(self)
        
        # Performance
        gb_perf = QGroupBox("Processing Engine")
        gl_perf = QGridLayout(gb_perf)
        gl_perf.addWidget(QLabel("Max Threads (0=Auto):"), 0, 0)
        self.spin_threads = QSpinBox()
        self.spin_threads.setRange(0, 32)
        self.spin_threads.setValue(int(CFG.get("max_threads")))
        gl_perf.addWidget(self.spin_threads, 0, 1)
        
        gl_perf.addWidget(QLabel("Safety Cap (Max Pixels):"), 1, 0)
        self.txt_pixels = QLineEdit(str(CFG.get("max_pixels")))
        gl_perf.addWidget(self.txt_pixels, 1, 1)
        layout.addWidget(gb_perf)
        
        # Defaults
        gb_def = QGroupBox("Workflow Defaults")
        gl_def = QGridLayout(gb_def)
        gl_def.addWidget(QLabel("Default Ingest:"), 0, 0)
        self.cb_ingest = QComboBox()
        self.cb_ingest.addItems(["Standard", "Lightning", "Deep"])
        self.cb_ingest.setCurrentText(CFG.get("default_ingest_mode"))
        gl_def.addWidget(self.cb_ingest, 0, 1)
        
        gl_def.addWidget(QLabel("Default Export:"), 1, 0)
        self.cb_export = QComboBox()
        self.cb_export.addItems(["Auto (Best Available)", "Force: OCR (Searchable)", "Force: Flattened (Visual)", "Force: Original Masters"])
        self.cb_export.setCurrentText(CFG.get("default_export_prio"))
        gl_def.addWidget(self.cb_export, 1, 1)
        layout.addWidget(gb_def)
        
        # OCR
        gb_ocr = QGroupBox("Optical Character Recognition (OCR)")
        gl_ocr = QVBoxLayout(gb_ocr)
        
        row_lang = QHBoxLayout()
        row_lang.addWidget(QLabel("Tesseract Language:"))
        self.cb_lang = QComboBox()
        langs = get_tesseract_langs()
        self.cb_lang.addItems(langs)
        
        cur = CFG.get("ocr_lang")
        idx = self.cb_lang.findText(cur, Qt.MatchContains)
        if idx >= 0: self.cb_lang.setCurrentIndex(idx)
        
        row_lang.addWidget(self.cb_lang)
        gl_ocr.addLayout(row_lang)
        
        row_btns = QHBoxLayout()
        btn_open_tess = QPushButton("Open Language Folder")
        btn_open_tess.clicked.connect(self.open_tess_folder)
        row_btns.addWidget(btn_open_tess)
        
        btn_get_langs = QPushButton("Get Languages (Web)")
        btn_get_langs.clicked.connect(lambda: webbrowser.open("https://github.com/tesseract-ocr/tessdata_best"))
        row_btns.addWidget(btn_get_langs)
        gl_ocr.addLayout(row_btns)
        layout.addWidget(gb_ocr)
        
        # Support
        gb_supp = QGroupBox("Support & Diagnostics")
        gl_supp = QVBoxLayout(gb_supp)
        
        self.btn_export_debug = QPushButton("Export Debug Bundle (Zipped Logs)")
        gl_supp.addWidget(self.btn_export_debug) # Connected in parent
        
        row_docs = QHBoxLayout()
        self.btn_cl = QPushButton("View Changelog")
        self.btn_ug = QPushButton("View User Guide")
        row_docs.addWidget(self.btn_cl)
        row_docs.addWidget(self.btn_ug)
        gl_supp.addLayout(row_docs)
        layout.addWidget(gb_supp)
        
        # Save
        btn_save = QPushButton("Save && Close") # FIX: Escape ampersand
        btn_save.setStyleSheet("font-weight: bold; padding: 8px;")
        btn_save.clicked.connect(self.save)
        layout.addWidget(btn_save)
        
    def open_tess_folder(self):
        try:
            import pytesseract
            path = os.environ.get("TESSDATA_PREFIX")
            if not path:
                path = str(Path(pytesseract.pytesseract.tesseract_cmd).parent / "tessdata")
            SystemUtils.open_file(path)
        except:
            QMessageBox.warning(self, "Error", "Could not locate Tesseract folder.")

    def save(self):
        CFG.set("max_threads", self.spin_threads.value())
        try:
            CFG.set("max_pixels", int(self.txt_pixels.text()))
        except: pass
        CFG.set("default_ingest_mode", self.cb_ingest.currentText())
        CFG.set("default_export_prio", self.cb_export.currentText())
        
        txt = self.cb_lang.currentText()
        if "(" in txt: code = txt.split("(")[1].replace(")", "")
        else: code = txt
        CFG.set("ocr_lang", code)
        
        self.accept()
==================== END FILE: docrefine\gui\dialogs.py ====================


==================== START FILE: docrefine\gui\forensic.py ====================
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QGraphicsView, QGraphicsScene, QGraphicsPixmapItem, QSplitter,
    QFrame, QMessageBox, QWidget, QSizePolicy
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QPixmap, QImage, QColor, QBrush
from docrefine.processing import convert_from_path, POPPLER_BIN
import time

class SyncGraphicsView(QGraphicsView):
    req_zoom = Signal(float)
    req_page = Signal(int)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QGraphicsView.AnchorUnderMouse)
        self.setBackgroundBrush(QBrush(QColor("#303030")))
        self.setScene(QGraphicsScene())
        self.last_scroll = 0

    def set_image(self, pixmap):
        self.scene().clear()
        item = QGraphicsPixmapItem(pixmap)
        self.scene().addItem(item)
        self.fitInView(self.scene().itemsBoundingRect(), Qt.KeepAspectRatio)

    def wheelEvent(self, event):
        modifiers = event.modifiers()
        if modifiers & Qt.ControlModifier:
            factor = 1.25 if event.angleDelta().y() > 0 else 0.8
            self.apply_zoom(factor)
            self.req_zoom.emit(factor)
        else:
            now = time.time()
            if now - self.last_scroll > 0.4: # Debounce page turns
                delta = 1 if event.angleDelta().y() < 0 else -1
                self.req_page.emit(delta)
                self.last_scroll = now

    def apply_zoom(self, factor):
        self.scale(factor, factor)

class ForensicDialog(QDialog):
    def __init__(self, ws_path, manifest, master_path, dup_candidates, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Forensic Verification (Sync View)")
        self.resize(1400, 900)
        self.setWindowFlags(self.windowFlags() | Qt.WindowMaximizeButtonHint)
        
        self.ws_path = ws_path
        self.manifest = manifest
        self.master_path = master_path
        self.dups = dup_candidates
        self.dup_idx = 0
        self.page = 1
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # --- Toolbar ---
        toolbar = QHBoxLayout()
        toolbar.addWidget(QLabel("MASTER:"))
        lbl_m = QLabel(master_path.name)
        lbl_m.setStyleSheet("font-weight: bold; color: #2ecc71; font-size: 11pt;")
        toolbar.addWidget(lbl_m)
        toolbar.addStretch()
        
        btn_prev = QPushButton("‚óÄ")
        btn_prev.setFixedWidth(40)
        btn_prev.clicked.connect(lambda: self.change_page(-1))
        self.lbl_page = QLabel("Page 1")
        self.lbl_page.setStyleSheet("font-weight: bold; padding: 0 15px;")
        btn_next = QPushButton("‚ñ∂")
        btn_next.setFixedWidth(40)
        btn_next.clicked.connect(lambda: self.change_page(1))
        
        toolbar.addWidget(btn_prev)
        toolbar.addWidget(self.lbl_page)
        toolbar.addWidget(btn_next)
        toolbar.addSpacing(30)
        
        btn_zo = QPushButton("‚àí")
        btn_zo.setFixedWidth(30)
        btn_zo.clicked.connect(lambda: self.manual_zoom(0.8))
        btn_zi = QPushButton("+")
        btn_zi.setFixedWidth(30)
        btn_zi.clicked.connect(lambda: self.manual_zoom(1.25))
        toolbar.addWidget(btn_zo)
        toolbar.addWidget(btn_zi)
        
        toolbar.addStretch()
        toolbar.addWidget(QLabel("CANDIDATE:"))
        self.lbl_dup_name = QLabel("")
        self.lbl_dup_name.setStyleSheet("font-weight: bold; color: #e74c3c; font-size: 11pt;")
        toolbar.addWidget(self.lbl_dup_name)
        layout.addLayout(toolbar)
        
        self.lbl_full_path = QLabel("Path: ...")
        self.lbl_full_path.setStyleSheet("color: #888; font-family: Consolas; margin-bottom: 5px;")
        layout.addWidget(self.lbl_full_path)
        
        # --- Split View ---
        splitter = QSplitter(Qt.Horizontal)
        splitter.setHandleWidth(12)
        
        self.view_master = SyncGraphicsView()
        self.view_dup = SyncGraphicsView()
        
        # Syncing
        self.view_master.verticalScrollBar().valueChanged.connect(self.view_dup.verticalScrollBar().setValue)
        self.view_dup.verticalScrollBar().valueChanged.connect(self.view_master.verticalScrollBar().setValue)
        self.view_master.horizontalScrollBar().valueChanged.connect(self.view_dup.horizontalScrollBar().setValue)
        self.view_dup.horizontalScrollBar().valueChanged.connect(self.view_master.horizontalScrollBar().setValue)
        
        self.view_master.req_zoom.connect(self.view_dup.apply_zoom)
        self.view_dup.req_zoom.connect(self.view_master.apply_zoom)
        self.view_master.req_page.connect(self.change_page)
        self.view_dup.req_page.connect(self.change_page)

        splitter.addWidget(self.view_master)
        splitter.addWidget(self.view_dup)
        
        # FIX: Force splitter to expand
        layout.addWidget(splitter, 1)
        
        # Bottom
        bot = QHBoxLayout()
        btn_prev_d = QPushButton("Previous Candidate")
        btn_prev_d.clicked.connect(lambda: self.change_dup(-1))
        self.lbl_dup_idx = QLabel("1 / N")
        btn_next_d = QPushButton("Next Candidate")
        btn_next_d.clicked.connect(lambda: self.change_dup(1))
        
        bot.addWidget(btn_prev_d)
        bot.addWidget(self.lbl_dup_idx)
        bot.addWidget(btn_next_d)
        bot.addStretch()
        
        btn_mark = QPushButton("MARK UNIQUE")
        btn_mark.setStyleSheet("background-color: green; color: white; font-weight: bold; padding: 6px 15px;")
        btn_mark.clicked.connect(self.mark_unique)
        bot.addWidget(btn_mark)
        layout.addLayout(bot)
        
        self.load_images()

    def render_file(self, path):
        if not path.exists(): return None
        if path.suffix.lower() == '.pdf':
            try:
                images = convert_from_path(str(path), first_page=self.page, last_page=self.page, poppler_path=POPPLER_BIN)
                if images:
                    im = images[0].convert("RGBA")
                    data = im.tobytes("raw", "RGBA")
                    qim = QImage(data, im.size[0], im.size[1], QImage.Format_RGBA8888)
                    return QPixmap.fromImage(qim)
            except: pass
        else:
            return QPixmap(str(path))
        return None

    def load_images(self):
        if not self.dups: return
        current_dup = self.dups[self.dup_idx]
        self.lbl_dup_name.setText(current_dup.name)
        self.lbl_full_path.setText(f"Candidate: {current_dup}")
        self.lbl_dup_idx.setText(f"{self.dup_idx + 1} / {len(self.dups)}")
        self.lbl_page.setText(f"Page {self.page}")

        pix_m = self.render_file(self.master_path)
        if pix_m: self.view_master.set_image(pix_m)
        pix_d = self.render_file(current_dup)
        if pix_d: self.view_dup.set_image(pix_d)

    def change_page(self, delta):
        if self.page + delta > 0:
            self.page += delta
            self.load_images()

    def change_dup(self, delta):
        new_idx = self.dup_idx + delta
        if 0 <= new_idx < len(self.dups):
            self.dup_idx = new_idx
            self.load_images()
            
    def manual_zoom(self, factor):
        self.view_master.apply_zoom(factor)
        self.view_dup.apply_zoom(factor)

    def mark_unique(self):
        QMessageBox.information(self, "Info", "Promotion logic pending backend connection.")
==================== END FILE: docrefine\gui\forensic.py ====================


==================== START FILE: docrefine\gui\main_window.py ====================
import json
from pathlib import Path
from datetime import datetime, timedelta
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QSplitter, QTreeWidget, QTreeWidgetItem, QPushButton, 
    QLabel, QProgressBar, QTextEdit, QTabWidget, QFrame,
    QCheckBox, QComboBox, QGroupBox, QHeaderView, QLineEdit,
    QMenu, QAbstractItemView, QGridLayout
)
from PySide6.QtCore import Qt, Slot, Signal, QTimer
from PySide6.QtGui import QColor
from docrefine.config import WORKSPACES_ROOT

class NumericTreeWidgetItem(QTreeWidgetItem):
    def __lt__(self, other):
        column = self.treeWidget().sortColumn()
        text1 = self.text(column)
        text2 = other.text(column)
        try: return float(text1) < float(text2)
        except ValueError: return text1 < text2

class MainWindow(QMainWindow):
    req_open_file = Signal(str) 
    req_reveal_file = Signal(str)
    req_compare = Signal(str)

    def __init__(self):
        super().__init__()
        self.setWindowTitle("DocRefine Pro (PySide6 Era)")
        self.resize(1300, 900)
        self.current_manifest = {}
        
        # Timer
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_timer)
        self.start_time = None
        self.accumulated_time = 0
        
        # Worker Slots Logic
        self.slot_map = {} # TID -> Index
        self.slot_widgets = []
        
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout(central)
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)
        
        # --- LEFT PANEL ---
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0,0,0,0)
        
        lbl_dash = QLabel("Workspace Dashboard")
        lbl_dash.setStyleSheet("font-weight: bold; font-size: 14px;")
        left_layout.addWidget(lbl_dash)
        
        self.btn_new_job = QPushButton("+ New Ingest Job")
        self.btn_new_job.setStyleSheet("padding: 6px; font-weight: bold;")
        left_layout.addWidget(self.btn_new_job)
        
        self.job_tree = QTreeWidget()
        self.job_tree.setHeaderLabels(["Name", "Status", "Date"])
        self.job_tree.header().setSectionResizeMode(0, QHeaderView.Stretch)
        self.job_tree.setSortingEnabled(True)
        self.job_tree.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.job_tree.setSelectionMode(QAbstractItemView.SingleSelection)
        self.job_tree.itemSelectionChanged.connect(self.on_job_selected)
        left_layout.addWidget(self.job_tree)
        
        self.gb_stats = QGroupBox("Job Statistics")
        self.gb_stats.setVisible(False)
        v_stats = QVBoxLayout(self.gb_stats)
        self.lbl_stat_files = QLabel("Files: -")
        self.lbl_stat_masters = QLabel("Masters: -")
        self.lbl_stat_q = QLabel("Quarantined: -")
        self.lbl_stat_time = QLabel("Time: -")
        v_stats.addWidget(self.lbl_stat_files)
        v_stats.addWidget(self.lbl_stat_masters)
        v_stats.addWidget(self.lbl_stat_q)
        v_stats.addWidget(self.lbl_stat_time)
        left_layout.addWidget(self.gb_stats)

        btn_row = QHBoxLayout()
        self.btn_refresh = QPushButton("Refresh")
        self.btn_refresh.clicked.connect(lambda: self.refresh_job_list(None))
        self.btn_delete = QPushButton("Delete Job")
        self.btn_delete.setStyleSheet("color: #ff5555; font-weight: bold;") 
        btn_row.addWidget(self.btn_refresh)
        btn_row.addWidget(self.btn_delete)
        left_layout.addLayout(btn_row)
        
        self.btn_settings = QPushButton("‚öô Settings")
        self.btn_open_folder = QPushButton("üìÇ Open Folder")
        self.btn_open_folder.setEnabled(False)
        self.btn_logs = QPushButton("üìú App Log")
        left_layout.addWidget(self.btn_settings)
        left_layout.addWidget(self.btn_open_folder)
        left_layout.addWidget(self.btn_logs)
        splitter.addWidget(left_panel)
        
        # --- RIGHT PANEL ---
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        self.tabs = QTabWidget()
        self.tab_refine = QWidget(); self._build_refine_tab()
        self.tab_export = QWidget(); self._build_export_tab()
        self.tab_inspect = QWidget(); self._build_inspector_tab()
        self.tabs.addTab(self.tab_refine, "1. Refine")
        self.tabs.addTab(self.tab_export, "2. Export")
        self.tabs.addTab(self.tab_inspect, "üîç Inspector")
        right_layout.addWidget(self.tabs)
        
        monitor_frame = QFrame()
        monitor_frame.setFrameShape(QFrame.StyledPanel)
        mon_layout = QVBoxLayout(monitor_frame)
        
        head_layout = QHBoxLayout()
        self.lbl_status = QLabel("Ready")
        self.lbl_status.setStyleSheet("color: #0078d7; font-weight: bold;")
        head_layout.addWidget(self.lbl_status)
        self.lbl_timer = QLabel("00:00:00")
        self.lbl_timer.setStyleSheet("font-family: Consolas; font-weight: bold;")
        head_layout.addWidget(self.lbl_timer)
        head_layout.addStretch()
        
        self.btn_receipt = QPushButton("View Receipt")
        self.btn_receipt.setEnabled(False)
        head_layout.addWidget(self.btn_receipt)
        
        self.btn_pause = QPushButton("Pause")
        self.btn_pause.setCheckable(True)
        self.btn_pause.setEnabled(False)
        head_layout.addWidget(self.btn_pause)
        
        self.btn_stop = QPushButton("STOP")
        self.btn_stop.setStyleSheet("background-color: #ff4444; color: white; font-weight: bold;")
        self.btn_stop.setEnabled(False)
        head_layout.addWidget(self.btn_stop)
        mon_layout.addLayout(head_layout)
        
        self.progress_main = QProgressBar()
        mon_layout.addWidget(self.progress_main)
        
        # Worker Slots
        self.slot_group = QGroupBox("Active Workers")
        self.slot_layout = QGridLayout(self.slot_group)
        mon_layout.addWidget(self.slot_group)
        
        self.log_box = QTextEdit()
        self.log_box.setReadOnly(True)
        self.log_box.setMaximumHeight(150)
        mon_layout.addWidget(self.log_box)
        
        right_layout.addWidget(monitor_frame)
        splitter.addWidget(right_panel)
        splitter.setSizes([350, 950])

    def _build_refine_tab(self):
        layout = QVBoxLayout(self.tab_refine)
        layout.setAlignment(Qt.AlignTop)
        layout.addWidget(QLabel("Content Refinement (Modifies Files)"))
        self.gb_pdf = QGroupBox("PDF Actions")
        gl_pdf = QVBoxLayout(self.gb_pdf)
        self.cb_pdf_mode = QComboBox()
        self.cb_pdf_mode.addItems(["No Action", "Flatten Only (Fast)", "Flatten + OCR (Slow)"])
        gl_pdf.addWidget(QLabel("Mode:"))
        gl_pdf.addWidget(self.cb_pdf_mode)
        layout.addWidget(self.gb_pdf)
        self.gb_gen = QGroupBox("General Actions")
        gl_gen = QVBoxLayout(self.gb_gen)
        self.chk_resize = QCheckBox("Resize Images (1920px HD Standard)")
        self.chk_img2pdf = QCheckBox("Bundle Images to PDF")
        self.chk_sanitize = QCheckBox("Sanitize Office Docs (Remove Metadata)")
        gl_gen.addWidget(self.chk_resize)
        gl_gen.addWidget(self.chk_img2pdf)
        gl_gen.addWidget(self.chk_sanitize)
        layout.addWidget(self.gb_gen)
        gb_qual = QGroupBox("Processing Quality")
        gl_qual = QHBoxLayout(gb_qual)
        self.cb_dpi = QComboBox()
        self.cb_dpi.addItems(["Low (Fast)", "Medium (Standard)", "High (Slow)"])
        self.cb_dpi.setCurrentIndex(1)
        gl_qual.addWidget(QLabel("DPI:"))
        gl_qual.addWidget(self.cb_dpi)
        self.btn_preview = QPushButton("Generate Preview")
        self.btn_preview.setEnabled(False)
        gl_qual.addWidget(self.btn_preview)
        layout.addWidget(gb_qual)
        self.btn_run_refine = QPushButton("Run Refinement Batch")
        self.btn_run_refine.setStyleSheet("font-weight: bold; padding: 10px;")
        self.btn_run_refine.setEnabled(False)
        layout.addWidget(self.btn_run_refine)

    def _build_export_tab(self):
        layout = QVBoxLayout(self.tab_export)
        layout.setAlignment(Qt.AlignTop)
        gb_prio = QGroupBox("Source Priority")
        vb_prio = QVBoxLayout(gb_prio)
        self.cb_prio = QComboBox()
        self.cb_prio.addItems(["Auto (Best Available)", "Force: OCR (Searchable)", "Force: Flattened (Visual)", "Force: Original Masters"])
        vb_prio.addWidget(self.cb_prio)
        self.chk_ext_src = QCheckBox("Override Source: External Folder")
        vb_prio.addWidget(self.chk_ext_src)
        layout.addWidget(gb_prio)
        gb_a = QGroupBox("Option A: Unique Masters")
        vb_a = QVBoxLayout(gb_a)
        self.btn_org = QPushButton("Export Unique Files")
        self.btn_org.setEnabled(False)
        vb_a.addWidget(self.btn_org)
        layout.addWidget(gb_a)
        gb_b = QGroupBox("Option B: Reconstruction")
        vb_b = QVBoxLayout(gb_b)
        self.btn_dist = QPushButton("Run Reconstruction")
        self.btn_dist.setEnabled(False)
        vb_b.addWidget(self.btn_dist)
        layout.addWidget(gb_b)
        gb_c = QGroupBox("Option C: Reports")
        vb_c = QVBoxLayout(gb_c)
        self.btn_csv = QPushButton("Export Full Inventory CSV")
        self.btn_csv.setEnabled(False)
        vb_c.addWidget(self.btn_csv)
        layout.addWidget(gb_c)

    def _build_inspector_tab(self):
        layout = QVBoxLayout(self.tab_inspect)
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("Filter:"))
        self.txt_search = QLineEdit()
        self.txt_search.textChanged.connect(self.filter_inspector)
        search_layout.addWidget(self.txt_search)
        layout.addLayout(search_layout)
        self.insp_tree = QTreeWidget()
        self.insp_tree.setHeaderLabels(["ID", "Name", "Status", "Copies"])
        self.insp_tree.header().setSectionResizeMode(1, QHeaderView.Stretch)
        self.insp_tree.setSortingEnabled(True)
        self.insp_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.insp_tree.customContextMenuRequested.connect(self.show_insp_context_menu)
        layout.addWidget(self.insp_tree)
        layout.addWidget(QLabel("Double-click a file to inspect details."))

    def show_insp_context_menu(self, pos):
        item = self.insp_tree.itemAt(pos)
        if not item: return
        menu = QMenu(self)
        a_open = menu.addAction("Open File")
        a_reveal = menu.addAction("Reveal in Folder")
        menu.addSeparator()
        a_comp = menu.addAction("Compare Duplicates (Forensic)")
        action = menu.exec_(self.insp_tree.viewport().mapToGlobal(pos))
        file_id = item.text(0)
        if action == a_open: self.req_open_file.emit(file_id)
        elif action == a_reveal: self.req_reveal_file.emit(file_id)
        elif action == a_comp: self.req_compare.emit(file_id)

    def refresh_job_list(self, auto_select_path=None):
        selected_path = auto_select_path
        if not selected_path:
            items = self.job_tree.selectedItems()
            if items: selected_path = items[0].data(0, Qt.UserRole)

        self.job_tree.blockSignals(True)
        disk_jobs = {}
        if WORKSPACES_ROOT.exists():
            for d in WORKSPACES_ROOT.iterdir():
                if d.is_dir():
                    status = "Empty"
                    if (d/"status.json").exists():
                        try: 
                            with open(d/"status.json") as f: status = json.load(f).get("stage", "?")
                        except: pass
                    elif (d/"Final_Delivery").exists(): status = "DISTRIBUTED"
                    elif (d/"01_Master_Files").exists(): status = "INGESTED"
                    date_str = datetime.fromtimestamp(d.stat().st_mtime).strftime('%Y-%m-%d %H:%M')
                    disk_jobs[str(d)] = {"name": d.name, "status": status, "date": date_str}

        root = self.job_tree.invisibleRootItem()
        existing_paths = set()
        to_remove = []
        for i in range(root.childCount()):
            item = root.child(i)
            path = item.data(0, Qt.UserRole)
            if path in disk_jobs:
                data = disk_jobs[path]
                if item.text(1) != data['status']: item.setText(1, data['status'])
                existing_paths.add(path)
            else: to_remove.append(item)
        for item in to_remove: root.removeChild(item)
        for path, data in disk_jobs.items():
            if path not in existing_paths:
                item = QTreeWidgetItem([data['name'], data['status'], data['date']])
                item.setData(0, Qt.UserRole, path)
                self.job_tree.addTopLevelItem(item)
        self.job_tree.blockSignals(False)
        
        if selected_path:
            for i in range(root.childCount()):
                item = root.child(i)
                if item.data(0, Qt.UserRole) == selected_path:
                    item.setSelected(True); break
        self.on_job_selected()

    def on_job_selected(self):
        items = self.job_tree.selectedItems()
        enabled = bool(items)
        self.btn_run_refine.setEnabled(enabled)
        self.btn_org.setEnabled(enabled)
        self.btn_dist.setEnabled(enabled)
        self.btn_csv.setEnabled(enabled)
        self.btn_open_folder.setEnabled(enabled)
        self.btn_preview.setEnabled(enabled)
        self.gb_stats.setVisible(enabled)
        self.btn_delete.setEnabled(enabled)
        self.insp_tree.clear()
        self.current_manifest = {}
        if enabled:
            path_str = items[0].data(0, Qt.UserRole)
            if not path_str: return
            ws_path = Path(path_str)
            self.update_refine_context(ws_path)
            self.load_stats(ws_path)
            rpt_dir = ws_path / "04_Reports"
            self.btn_receipt.setEnabled(rpt_dir.exists() and any(rpt_dir.glob("*.html")))
            if (ws_path / "manifest.json").exists():
                try: 
                    with open(ws_path / "manifest.json") as f: self.current_manifest = json.load(f)
                    self.filter_inspector("")
                except: pass
        else:
            self.reset_stats()

    def reset_stats(self):
        self.lbl_stat_files.setText("Files: -")
        self.lbl_stat_masters.setText("Masters: -")
        self.lbl_stat_q.setText("Quarantined: -")
        self.lbl_stat_time.setText("Time: -")

    def load_stats(self, ws_path):
        try:
            with open(ws_path / "stats.json") as f: s = json.load(f)
            self.lbl_stat_files.setText(f"Files Scanned: {s.get('total_scanned', 0)}")
            self.lbl_stat_masters.setText(f"Unique Masters: {s.get('masters', 0)}")
            self.lbl_stat_q.setText(f"Quarantined: {s.get('quarantined', 0)}")
            sec = int(s.get('ingest_time',0) + s.get('batch_time',0))
            self.lbl_stat_time.setText(f"Total Time: {str(timedelta(seconds=sec))}")
        except: self.reset_stats()

    def update_refine_context(self, ws_path):
        m = ws_path / "01_Master_Files"
        has_pdf = False; has_img = False; has_office = False
        if m.exists():
            for f in m.rglob('*'):
                e = f.suffix.lower()
                if e == '.pdf': has_pdf = True
                elif e in {'.jpg','.png'}: has_img = True
                elif e in {'.docx','.xlsx'}: has_office = True
        self.gb_pdf.setVisible(has_pdf); self.gb_gen.setVisible(has_img or has_office)

    def filter_inspector(self, text):
        self.insp_tree.clear()
        query = text.lower()
        for k, v in self.current_manifest.items():
            name = v.get('name', '').lower()
            if query in name or query in v.get('id','').lower():
                st = "Duplicate" if len(v.get('copies', []))>1 else "Master"
                if v.get('status') == 'QUARANTINE': st = "‚õî Quarantined"
                item = NumericTreeWidgetItem([v.get('id','?'), v.get('name','?'), st, str(len(v.get('copies',[])))])
                if "Quar" in st: item.setForeground(2, QColor("#e74c3c"))
                elif "Dup" in st: item.setForeground(2, QColor("#3498db"))
                self.insp_tree.addTopLevelItem(item)

    # --- STATE ---
    def set_processing_state(self, active, multi_threaded=False):
        self.btn_new_job.setEnabled(not active)
        self.btn_delete.setEnabled(not active)
        self.btn_run_refine.setEnabled(not active)
        self.btn_pause.setEnabled(active)
        self.btn_stop.setEnabled(active)
        self.slot_group.setVisible(active and multi_threaded)
        
        if active:
            self.reset_stats()
            self.start_time = datetime.now()
            self.timer.start(1000)
        else:
            self.timer.stop()
            self.accumulated_time = 0
            self.lbl_timer.setText("00:00:00")
            self.refresh_job_list(None)

    def pause_timer(self, paused):
        if paused:
            self.timer.stop()
            self.accumulated_time += (datetime.now() - self.start_time).total_seconds()
        else:
            self.start_time = datetime.now()
            self.timer.start(1000)

    def update_timer(self):
        if self.start_time:
            now = datetime.now()
            delta = (now - self.start_time).total_seconds() + self.accumulated_time
            self.lbl_timer.setText(str(timedelta(seconds=int(delta))))

    @Slot(int)
    def setup_slots(self, count):
        # FIX: Full reset of mapping logic
        for i in reversed(range(self.slot_layout.count())): 
            self.slot_layout.itemAt(i).widget().setParent(None)
        
        self.slot_map = {} # Reset TID map
        self.slot_widgets = [] # Reset Widget list
        
        row = 0; col = 0
        for i in range(count):
            lbl = QLabel(f"W{i+1}: Idle")
            lbl.setStyleSheet("background-color: #333; color: white; padding: 4px; border-radius: 4px;")
            self.slot_layout.addWidget(lbl, row, col)
            self.slot_widgets.append(lbl)
            col += 1
            if col > 3: col = 0; row += 1

    @Slot(dict)
    def update_slot(self, data):
        # FIX: Assign new TIDs to next available slot
        tid = data.get('tid')
        
        if tid not in self.slot_map:
            # New thread appeared
            next_idx = len(self.slot_map)
            if next_idx < len(self.slot_widgets):
                self.slot_map[tid] = next_idx
            else:
                return # Should not happen if worker count logic matches
        
        idx = self.slot_map[tid]
        self.slot_widgets[idx].setText(data.get('text'))

    @Slot(str, str)
    def update_log(self, msg, level):
        c = "#ff5555" if level == "ERROR" else "#ccc"
        if level == "INFO": c = "#ddd"
        self.log_box.append(f'<span style="color:{c}">[{level}] {msg}</span>')

    @Slot(float, str)
    def update_progress(self, percent, text):
        self.progress_main.setValue(int(percent))
        self.lbl_status.setText(text)
        
    @Slot(str, str, str)
    def update_status_label(self, stage, msg, color):
        self.lbl_status.setText(msg)
        c = {"blue": "#55aaff", "green": "#55ff55", "red": "#ff5555", "orange": "#ffaa00"}.get(color, "#ffffff")
        self.lbl_status.setStyleSheet(f"color: {c}; font-weight: bold;")

    @Slot()
    def job_done(self):
        self.progress_main.setValue(100)
        self.lbl_status.setText("Completed")
        self.set_processing_state(False)
==================== END FILE: docrefine\gui\main_window.py ====================


==================== START FILE: docrefine\gui\qt_adapter.py ====================
from PySide6.QtCore import QObject, Signal, Slot
from docrefine.core.events import AppEvent, EventType

class DocRefineAdapter(QObject):
    """
    The Diplomat.
    Translates 'Worker Events' (Data) -> 'Qt Signals' (UI Actions).
    """
    
    # Define strongly-typed Qt Signals matching our Event Types
    sig_log = Signal(str, str)              # msg, level
    sig_progress_main = Signal(float, str)  # percent, text
    sig_slot_update = Signal(dict)          # {tid, text, percent}
    sig_worker_config = Signal(int)         # num_workers
    sig_status = Signal(str, str, str)      # stage, msg, color_hint
    sig_job_data = Signal(str)              # workspace_path
    sig_notification = Signal(dict)         # {title, msg, open_path}
    sig_error = Signal(str)
    sig_done = Signal()

    def __init__(self):
        super().__init__()

    def ingest_event(self, event: AppEvent):
        """
        The Callback. This runs on the WORKER THREAD.
        Qt Signals are thread-safe, so emitting them here safely 
        transfers execution to the Main Thread.
        """
        p = event.payload
        
        if event.type == EventType.LOG:
            self.sig_log.emit(p['msg'], p['level'])
            
        elif event.type == EventType.PROGRESS_MAIN:
            self.sig_progress_main.emit(p['percent'], p['text'])
        
        elif event.type == EventType.SLOT_UPDATE:
            self.sig_slot_update.emit(p)
            
        elif event.type == EventType.WORKER_CONFIG:
            self.sig_worker_config.emit(p)
            
        elif event.type == EventType.STATUS_CHANGE:
            self.sig_status.emit(p['stage'], p['msg'], p['color'])
            
        elif event.type == EventType.JOB_DATA:
            self.sig_job_data.emit(p)
            
        elif event.type == EventType.NOTIFICATION:
            self.sig_notification.emit(p)
            
        elif event.type == EventType.ERROR:
            self.sig_error.emit(str(p))
            
        elif event.type == EventType.DONE:
            self.sig_done.emit()
==================== END FILE: docrefine\gui\qt_adapter.py ====================


==================== START FILE: poppler\share\poppler\CMakeLists.txt ====================
cmake_minimum_required(VERSION 3.10.0 FATAL_ERROR)

project(poppler-data NONE)

set(VERSION "0.4.12")
set(datadir ${CMAKE_INSTALL_PREFIX}/share)
set(pkgdatadir ${datadir}/poppler)

set(unicode-map-files
  unicodeMap/Big5
  unicodeMap/Big5ascii
  unicodeMap/EUC-CN
  unicodeMap/EUC-JP
  unicodeMap/GBK
  unicodeMap/ISO-2022-CN
  unicodeMap/ISO-2022-JP
  unicodeMap/ISO-2022-KR
  unicodeMap/ISO-8859-6
  unicodeMap/ISO-8859-7
  unicodeMap/ISO-8859-8
  unicodeMap/ISO-8859-9
  unicodeMap/KOI8-R
  unicodeMap/Latin2
  unicodeMap/Shift-JIS
  unicodeMap/TIS-620
  unicodeMap/Windows-1255
)
install(FILES ${unicode-map-files} DESTINATION ${pkgdatadir}/unicodeMap)

set(cMap-files-AC1
  cMap/Adobe-CNS1/Adobe-CNS1-0
  cMap/Adobe-CNS1/Adobe-CNS1-1
  cMap/Adobe-CNS1/Adobe-CNS1-2
  cMap/Adobe-CNS1/Adobe-CNS1-3
  cMap/Adobe-CNS1/Adobe-CNS1-4
  cMap/Adobe-CNS1/Adobe-CNS1-5
  cMap/Adobe-CNS1/Adobe-CNS1-6
  cMap/Adobe-CNS1/Adobe-CNS1-7
  cMap/Adobe-CNS1/Adobe-CNS1-B5pc
  cMap/Adobe-CNS1/Adobe-CNS1-ETen-B5
  cMap/Adobe-CNS1/Adobe-CNS1-H-CID
  cMap/Adobe-CNS1/Adobe-CNS1-H-Host
  cMap/Adobe-CNS1/Adobe-CNS1-H-Mac
  cMap/Adobe-CNS1/Adobe-CNS1-UCS2
  cMap/Adobe-CNS1/B5-H
  cMap/Adobe-CNS1/B5pc-H
  cMap/Adobe-CNS1/B5pc-UCS2
  cMap/Adobe-CNS1/B5pc-UCS2C
  cMap/Adobe-CNS1/B5pc-V
  cMap/Adobe-CNS1/B5-V
  cMap/Adobe-CNS1/CNS1-H
  cMap/Adobe-CNS1/CNS1-V
  cMap/Adobe-CNS1/CNS2-H
  cMap/Adobe-CNS1/CNS2-V
  cMap/Adobe-CNS1/CNS-EUC-H
  cMap/Adobe-CNS1/CNS-EUC-V
  cMap/Adobe-CNS1/ETen-B5-H
  cMap/Adobe-CNS1/ETen-B5-UCS2
  cMap/Adobe-CNS1/ETen-B5-V
  cMap/Adobe-CNS1/ETenms-B5-H
  cMap/Adobe-CNS1/ETenms-B5-V
  cMap/Adobe-CNS1/ETHK-B5-H
  cMap/Adobe-CNS1/ETHK-B5-V
  cMap/Adobe-CNS1/HKdla-B5-H
  cMap/Adobe-CNS1/HKdla-B5-V
  cMap/Adobe-CNS1/HKdlb-B5-H
  cMap/Adobe-CNS1/HKdlb-B5-V
  cMap/Adobe-CNS1/HKgccs-B5-H
  cMap/Adobe-CNS1/HKgccs-B5-V
  cMap/Adobe-CNS1/HKm314-B5-H
  cMap/Adobe-CNS1/HKm314-B5-V
  cMap/Adobe-CNS1/HKm471-B5-H
  cMap/Adobe-CNS1/HKm471-B5-V
  cMap/Adobe-CNS1/HKscs-B5-H
  cMap/Adobe-CNS1/HKscs-B5-V
  cMap/Adobe-CNS1/UCS2-B5pc
  cMap/Adobe-CNS1/UCS2-ETen-B5
  cMap/Adobe-CNS1/UniCNS-UCS2-H
  cMap/Adobe-CNS1/UniCNS-UCS2-V
  cMap/Adobe-CNS1/UniCNS-UTF16-H
  cMap/Adobe-CNS1/UniCNS-UTF16-V
  cMap/Adobe-CNS1/UniCNS-UTF32-H
  cMap/Adobe-CNS1/UniCNS-UTF32-V
  cMap/Adobe-CNS1/UniCNS-UTF8-H
  cMap/Adobe-CNS1/UniCNS-UTF8-V
)
install(FILES ${cMap-files-AC1} DESTINATION ${pkgdatadir}/cMap/Adobe-CNS1)

set(cMap-files-AG1
  cMap/Adobe-GB1/Adobe-GB1-0
  cMap/Adobe-GB1/Adobe-GB1-1
  cMap/Adobe-GB1/Adobe-GB1-2
  cMap/Adobe-GB1/Adobe-GB1-3
  cMap/Adobe-GB1/Adobe-GB1-4
  cMap/Adobe-GB1/Adobe-GB1-5
  cMap/Adobe-GB1/Adobe-GB1-GBK-EUC
  cMap/Adobe-GB1/Adobe-GB1-GBpc-EUC
  cMap/Adobe-GB1/Adobe-GB1-H-CID
  cMap/Adobe-GB1/Adobe-GB1-H-Host
  cMap/Adobe-GB1/Adobe-GB1-H-Mac
  cMap/Adobe-GB1/Adobe-GB1-UCS2
  cMap/Adobe-GB1/GB-EUC-H
  cMap/Adobe-GB1/GB-EUC-V
  cMap/Adobe-GB1/GB-H
  cMap/Adobe-GB1/GBK2K-H
  cMap/Adobe-GB1/GBK2K-V
  cMap/Adobe-GB1/GBK-EUC-H
  cMap/Adobe-GB1/GBK-EUC-UCS2
  cMap/Adobe-GB1/GBK-EUC-V
  cMap/Adobe-GB1/GBKp-EUC-H
  cMap/Adobe-GB1/GBKp-EUC-V
  cMap/Adobe-GB1/GBpc-EUC-H
  cMap/Adobe-GB1/GBpc-EUC-UCS2
  cMap/Adobe-GB1/GBpc-EUC-UCS2C
  cMap/Adobe-GB1/GBpc-EUC-V
  cMap/Adobe-GB1/GBT-EUC-H
  cMap/Adobe-GB1/GBT-EUC-V
  cMap/Adobe-GB1/GBT-H
  cMap/Adobe-GB1/GBTpc-EUC-H
  cMap/Adobe-GB1/GBTpc-EUC-V
  cMap/Adobe-GB1/GBT-V
  cMap/Adobe-GB1/GB-V
  cMap/Adobe-GB1/UCS2-GBK-EUC
  cMap/Adobe-GB1/UCS2-GBpc-EUC
  cMap/Adobe-GB1/UniGB-UCS2-H
  cMap/Adobe-GB1/UniGB-UCS2-V
  cMap/Adobe-GB1/UniGB-UTF16-H
  cMap/Adobe-GB1/UniGB-UTF16-V
  cMap/Adobe-GB1/UniGB-UTF32-H
  cMap/Adobe-GB1/UniGB-UTF32-V
  cMap/Adobe-GB1/UniGB-UTF8-H
  cMap/Adobe-GB1/UniGB-UTF8-V
)
install(FILES ${cMap-files-AG1} DESTINATION ${pkgdatadir}/cMap/Adobe-GB1)

set(cMap-files-AJ1
  cMap/Adobe-Japan1/78-EUC-H
  cMap/Adobe-Japan1/78-EUC-V
  cMap/Adobe-Japan1/78-H
  cMap/Adobe-Japan1/78ms-RKSJ-H
  cMap/Adobe-Japan1/78ms-RKSJ-V
  cMap/Adobe-Japan1/78-RKSJ-H
  cMap/Adobe-Japan1/78-RKSJ-V
  cMap/Adobe-Japan1/78-V
  cMap/Adobe-Japan1/83pv-RKSJ-H
  cMap/Adobe-Japan1/90msp-RKSJ-H
  cMap/Adobe-Japan1/90msp-RKSJ-V
  cMap/Adobe-Japan1/90ms-RKSJ-H
  cMap/Adobe-Japan1/90ms-RKSJ-UCS2
  cMap/Adobe-Japan1/90ms-RKSJ-V
  cMap/Adobe-Japan1/90pv-RKSJ-H
  cMap/Adobe-Japan1/90pv-RKSJ-UCS2
  cMap/Adobe-Japan1/90pv-RKSJ-UCS2C
  cMap/Adobe-Japan1/90pv-RKSJ-V
  cMap/Adobe-Japan1/Add-H
  cMap/Adobe-Japan1/Add-RKSJ-H
  cMap/Adobe-Japan1/Add-RKSJ-V
  cMap/Adobe-Japan1/Add-V
  cMap/Adobe-Japan1/Adobe-Japan1-0
  cMap/Adobe-Japan1/Adobe-Japan1-1
  cMap/Adobe-Japan1/Adobe-Japan1-2
  cMap/Adobe-Japan1/Adobe-Japan1-3
  cMap/Adobe-Japan1/Adobe-Japan1-4
  cMap/Adobe-Japan1/Adobe-Japan1-5
  cMap/Adobe-Japan1/Adobe-Japan1-6
  cMap/Adobe-Japan1/Adobe-Japan1-7
  cMap/Adobe-Japan1/Adobe-Japan1-90ms-RKSJ
  cMap/Adobe-Japan1/Adobe-Japan1-90pv-RKSJ
  cMap/Adobe-Japan1/Adobe-Japan1-H-CID
  cMap/Adobe-Japan1/Adobe-Japan1-H-Host
  cMap/Adobe-Japan1/Adobe-Japan1-H-Mac
  cMap/Adobe-Japan1/Adobe-Japan1-PS-H
  cMap/Adobe-Japan1/Adobe-Japan1-PS-V
  cMap/Adobe-Japan1/Adobe-Japan1-UCS2
  cMap/Adobe-Japan1/EUC-H
  cMap/Adobe-Japan1/EUC-V
  cMap/Adobe-Japan1/Ext-H
  cMap/Adobe-Japan1/Ext-RKSJ-H
  cMap/Adobe-Japan1/Ext-RKSJ-V
  cMap/Adobe-Japan1/Ext-V
  cMap/Adobe-Japan1/H
  cMap/Adobe-Japan1/Hankaku
  cMap/Adobe-Japan1/Hiragana
  cMap/Adobe-Japan1/Hojo-EUC-H
  cMap/Adobe-Japan1/Hojo-EUC-V
  cMap/Adobe-Japan1/Hojo-H
  cMap/Adobe-Japan1/Hojo-V
  cMap/Adobe-Japan1/Katakana
  cMap/Adobe-Japan1/NWP-H
  cMap/Adobe-Japan1/NWP-V
  cMap/Adobe-Japan1/RKSJ-H
  cMap/Adobe-Japan1/RKSJ-V
  cMap/Adobe-Japan1/Roman
  cMap/Adobe-Japan1/UCS2-90ms-RKSJ
  cMap/Adobe-Japan1/UCS2-90pv-RKSJ
  cMap/Adobe-Japan1/UniHojo-UCS2-H
  cMap/Adobe-Japan1/UniHojo-UCS2-V
  cMap/Adobe-Japan1/UniHojo-UTF16-H
  cMap/Adobe-Japan1/UniHojo-UTF16-V
  cMap/Adobe-Japan1/UniHojo-UTF32-H
  cMap/Adobe-Japan1/UniHojo-UTF32-V
  cMap/Adobe-Japan1/UniHojo-UTF8-H
  cMap/Adobe-Japan1/UniHojo-UTF8-V
  cMap/Adobe-Japan1/UniJIS2004-UTF16-H
  cMap/Adobe-Japan1/UniJIS2004-UTF16-V
  cMap/Adobe-Japan1/UniJIS2004-UTF32-H
  cMap/Adobe-Japan1/UniJIS2004-UTF32-V
  cMap/Adobe-Japan1/UniJIS2004-UTF8-H
  cMap/Adobe-Japan1/UniJIS2004-UTF8-V
  cMap/Adobe-Japan1/UniJISPro-UCS2-HW-V
  cMap/Adobe-Japan1/UniJISPro-UCS2-V
  cMap/Adobe-Japan1/UniJISPro-UTF8-V
  cMap/Adobe-Japan1/UniJIS-UCS2-H
  cMap/Adobe-Japan1/UniJIS-UCS2-HW-H
  cMap/Adobe-Japan1/UniJIS-UCS2-HW-V
  cMap/Adobe-Japan1/UniJIS-UCS2-V
  cMap/Adobe-Japan1/UniJIS-UTF16-H
  cMap/Adobe-Japan1/UniJIS-UTF16-V
  cMap/Adobe-Japan1/UniJIS-UTF32-H
  cMap/Adobe-Japan1/UniJIS-UTF32-V
  cMap/Adobe-Japan1/UniJIS-UTF8-H
  cMap/Adobe-Japan1/UniJIS-UTF8-V
  cMap/Adobe-Japan1/UniJISX02132004-UTF32-H
  cMap/Adobe-Japan1/UniJISX02132004-UTF32-V
  cMap/Adobe-Japan1/UniJISX0213-UTF32-H
  cMap/Adobe-Japan1/UniJISX0213-UTF32-V
  cMap/Adobe-Japan1/V
  cMap/Adobe-Japan1/WP-Symbol
)
install(FILES ${cMap-files-AJ1} DESTINATION ${pkgdatadir}/cMap/Adobe-Japan1)

set(cMap-files-AJ2
  cMap/Adobe-Japan2/Adobe-Japan2-0
)
install(FILES ${cMap-files-AJ2} DESTINATION ${pkgdatadir}/cMap/Adobe-Japan2)

set(cMap-files-AK1
  cMap/Adobe-Korea1/Adobe-Korea1-0
  cMap/Adobe-Korea1/Adobe-Korea1-1
  cMap/Adobe-Korea1/Adobe-Korea1-2
  cMap/Adobe-Korea1/Adobe-Korea1-H-CID
  cMap/Adobe-Korea1/Adobe-Korea1-H-Host
  cMap/Adobe-Korea1/Adobe-Korea1-H-Mac
  cMap/Adobe-Korea1/Adobe-Korea1-KSCms-UHC
  cMap/Adobe-Korea1/Adobe-Korea1-KSCpc-EUC
  cMap/Adobe-Korea1/Adobe-Korea1-UCS2
  cMap/Adobe-Korea1/KSC-EUC-H
  cMap/Adobe-Korea1/KSC-EUC-V
  cMap/Adobe-Korea1/KSC-H
  cMap/Adobe-Korea1/KSC-Johab-H
  cMap/Adobe-Korea1/KSC-Johab-V
  cMap/Adobe-Korea1/KSCms-UHC-H
  cMap/Adobe-Korea1/KSCms-UHC-HW-H
  cMap/Adobe-Korea1/KSCms-UHC-HW-V
  cMap/Adobe-Korea1/KSCms-UHC-UCS2
  cMap/Adobe-Korea1/KSCms-UHC-V
  cMap/Adobe-Korea1/KSCpc-EUC-H
  cMap/Adobe-Korea1/KSCpc-EUC-UCS2
  cMap/Adobe-Korea1/KSCpc-EUC-UCS2C
  cMap/Adobe-Korea1/KSCpc-EUC-V
  cMap/Adobe-Korea1/KSC-V
  cMap/Adobe-Korea1/UCS2-KSCms-UHC
  cMap/Adobe-Korea1/UCS2-KSCpc-EUC
  cMap/Adobe-Korea1/UniKS-UCS2-H
  cMap/Adobe-Korea1/UniKS-UCS2-V
  cMap/Adobe-Korea1/UniKS-UTF16-H
  cMap/Adobe-Korea1/UniKS-UTF16-V
  cMap/Adobe-Korea1/UniKS-UTF32-H
  cMap/Adobe-Korea1/UniKS-UTF32-V
  cMap/Adobe-Korea1/UniKS-UTF8-H
  cMap/Adobe-Korea1/UniKS-UTF8-V
)
install(FILES ${cMap-files-AK1} DESTINATION ${pkgdatadir}/cMap/Adobe-Korea1)

set(cMap-files-AKR
  cMap/Adobe-KR/Adobe-KR-0
  cMap/Adobe-KR/Adobe-KR-1
  cMap/Adobe-KR/Adobe-KR-2
  cMap/Adobe-KR/Adobe-KR-3
  cMap/Adobe-KR/Adobe-KR-4
  cMap/Adobe-KR/Adobe-KR-5
  cMap/Adobe-KR/Adobe-KR-6
  cMap/Adobe-KR/Adobe-KR-7
  cMap/Adobe-KR/Adobe-KR-8
  cMap/Adobe-KR/Adobe-KR-9
  cMap/Adobe-KR/Adobe-KR-UCS2
  cMap/Adobe-KR/UniAKR-UTF16-H
  cMap/Adobe-KR/UniAKR-UTF32-H
  cMap/Adobe-KR/UniAKR-UTF8-H
)
install(FILES ${cMap-files-AKR} DESTINATION ${pkgdatadir}/cMap/Adobe-KR)

set(name-to-unicode-files
  nameToUnicode/Bulgarian
  nameToUnicode/Greek
  nameToUnicode/Thai
)
install(FILES ${name-to-unicode-files} DESTINATION ${pkgdatadir}/nameToUnicode)

set(cid-to-unicode-files
  cidToUnicode/Adobe-GB1
  cidToUnicode/Adobe-CNS1
  cidToUnicode/Adobe-Japan1
  cidToUnicode/Adobe-Korea1
)
install(FILES ${cid-to-unicode-files} DESTINATION ${pkgdatadir}/cidToUnicode)

configure_file(poppler-data.pc.in poppler-data.pc @ONLY)
install(FILES ${CMAKE_CURRENT_BINARY_DIR}/poppler-data.pc DESTINATION ${datadir}/pkgconfig)

==================== END FILE: poppler\share\poppler\CMakeLists.txt ====================


==================== START FILE: Tesseract-OCR\doc\README.md ====================
# Tesseract OCR

[![Coverity Scan Build Status](https://scan.coverity.com/projects/tesseract-ocr/badge.svg)](https://scan.coverity.com/projects/tesseract-ocr)
[![CodeQL](https://github.com/tesseract-ocr/tesseract/workflows/CodeQL/badge.svg)](https://github.com/tesseract-ocr/tesseract/security/code-scanning)
[![OSS-Fuzz](https://img.shields.io/badge/oss--fuzz-fuzzing-brightgreen)](https://issues.oss-fuzz.com/issues?q=is:open%20title:tesseract-ocr)
\
[![GitHub license](https://img.shields.io/badge/license-Apache--2.0-blue.svg)](https://raw.githubusercontent.com/tesseract-ocr/tesseract/main/LICENSE)
[![Downloads](https://img.shields.io/badge/download-all%20releases-brightgreen.svg)](https://github.com/tesseract-ocr/tesseract/releases/)

## Table of Contents

* [Tesseract OCR](#tesseract-ocr)
  * [About](#about)
  * [Brief history](#brief-history)
  * [Installing Tesseract](#installing-tesseract)
  * [Running Tesseract](#running-tesseract)
  * [For developers](#for-developers)
  * [Support](#support)
  * [License](#license)
  * [Dependencies](#dependencies)
  * [Latest Version of README](#latest-version-of-readme)

## About

This package contains an **OCR engine** - `libtesseract` and a **command line program** - `tesseract`.

Tesseract 4 adds a new neural net (LSTM) based [OCR engine](https://en.wikipedia.org/wiki/Optical_character_recognition) which is focused on line recognition, but also still supports the legacy Tesseract OCR engine of Tesseract 3 which works by recognizing character patterns. Compatibility with Tesseract 3 is enabled by using the Legacy OCR Engine mode (--oem 0).
It also needs [traineddata](https://tesseract-ocr.github.io/tessdoc/Data-Files.html) files which support the legacy engine, for example those from the [tessdata](https://github.com/tesseract-ocr/tessdata) repository.

Stefan Weil is the current lead developer. Ray Smith was the lead developer until 2018. The maintainer is Zdenko Podobny. For a list of contributors see [AUTHORS](https://github.com/tesseract-ocr/tesseract/blob/main/AUTHORS)
and GitHub's log of [contributors](https://github.com/tesseract-ocr/tesseract/graphs/contributors).

Tesseract has **unicode (UTF-8) support**, and can **recognize [more than 100 languages](https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html)** "out of the box".

Tesseract supports **[various image formats](https://tesseract-ocr.github.io/tessdoc/InputFormats)** including PNG, JPEG and TIFF.

Tesseract supports **various output formats**: plain text, hOCR (HTML), PDF, invisible-text-only PDF, TSV, ALTO and PAGE.

You should note that in many cases, in order to get better OCR results, you'll need to **[improve the quality](https://tesseract-ocr.github.io/tessdoc/ImproveQuality.html) of the image** you are giving Tesseract.

This project **does not include a GUI application**. If you need one, please see the [3rdParty](https://tesseract-ocr.github.io/tessdoc/User-Projects-%E2%80%93-3rdParty.html) documentation.

Tesseract **can be trained to recognize other languages**.
See [Tesseract Training](https://tesseract-ocr.github.io/tessdoc/Training-Tesseract.html) for more information.

## Brief history

Tesseract was originally developed at Hewlett-Packard Laboratories Bristol UK and at Hewlett-Packard Co, Greeley Colorado USA between 1985 and 1994, with some more changes made in 1996 to port to Windows, and some C++izing in 1998. In 2005 Tesseract was open sourced by HP. From 2006 until November 2018 it was developed by Google.

Major version 5 is the current stable version and started with release
[5.0.0](https://github.com/tesseract-ocr/tesseract/releases/tag/5.0.0) on November 30, 2021. Newer minor versions and bugfix versions are available from
[GitHub](https://github.com/tesseract-ocr/tesseract/releases/).

Latest source code is available from [main branch on GitHub](https://github.com/tesseract-ocr/tesseract/tree/main).
Open issues can be found in [issue tracker](https://github.com/tesseract-ocr/tesseract/issues),
and [planning documentation](https://tesseract-ocr.github.io/tessdoc/Planning.html).

See **[Release Notes](https://tesseract-ocr.github.io/tessdoc/ReleaseNotes.html)**
and **[Change Log](https://github.com/tesseract-ocr/tesseract/blob/main/ChangeLog)** for more details of the releases.

## Installing Tesseract

You can either [Install Tesseract via pre-built binary package](https://tesseract-ocr.github.io/tessdoc/Installation.html)
or [build it from source](https://tesseract-ocr.github.io/tessdoc/Compiling.html).

Before building Tesseract from source, please check that your system has a compiler which is one of the [supported compilers](https://tesseract-ocr.github.io/tessdoc/supported-compilers.html).

## Running Tesseract

Basic **[command line usage](https://tesseract-ocr.github.io/tessdoc/Command-Line-Usage.html)**:

    tesseract imagename outputbase [-l lang] [--oem ocrenginemode] [--psm pagesegmode] [configfiles...]

For more information about the various command line options use `tesseract --help` or `man tesseract`.

Examples can be found in the [documentation](https://tesseract-ocr.github.io/tessdoc/Command-Line-Usage.html#simplest-invocation-to-ocr-an-image).

## For developers

Developers can use `libtesseract` [C](https://github.com/tesseract-ocr/tesseract/blob/main/include/tesseract/capi.h) or
[C++](https://github.com/tesseract-ocr/tesseract/blob/main/include/tesseract/baseapi.h) API to build their own application. If you need bindings to `libtesseract` for other programming languages, please see the
[wrapper](https://tesseract-ocr.github.io/tessdoc/AddOns.html#tesseract-wrappers) section in the AddOns documentation.

Documentation of Tesseract generated from source code by doxygen can be found on [tesseract-ocr.github.io](https://tesseract-ocr.github.io/).

## Support

Before you submit an issue, please review **[the guidelines for this repository](https://github.com/tesseract-ocr/tesseract/blob/main/CONTRIBUTING.md)**.

For support, first read the [documentation](https://tesseract-ocr.github.io/tessdoc/),
particularly the [FAQ](https://tesseract-ocr.github.io/tessdoc/FAQ.html) to see if your problem is addressed there.
If not, search the [Tesseract user forum](https://groups.google.com/g/tesseract-ocr), the [Tesseract developer forum](https://groups.google.com/g/tesseract-dev) and [past issues](https://github.com/tesseract-ocr/tesseract/issues), and if you still can't find what you need, ask for support in the mailing-lists.

Mailing-lists:

* [tesseract-ocr](https://groups.google.com/g/tesseract-ocr) - For tesseract users.
* [tesseract-dev](https://groups.google.com/g/tesseract-dev) - For tesseract developers.

Please report an issue only for a **bug**, not for asking questions.

## License

    The code in this repository is licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

**NOTE**: This software depends on other packages that may be licensed under different open source licenses.

Tesseract uses [Leptonica library](http://leptonica.com/) which essentially
uses a [BSD 2-clause license](http://leptonica.com/about-the-license.html).

## Dependencies

Tesseract uses [Leptonica library](https://github.com/DanBloomberg/leptonica)
for opening input images (e.g. not documents like pdf).
It is suggested to use leptonica with built-in support for [zlib](https://zlib.net),
[png](https://sourceforge.net/projects/libpng) and
[tiff](http://www.simplesystems.org/libtiff) (for multipage tiff).

## Latest Version of README

For the latest online version of the README.md see:

<https://github.com/tesseract-ocr/tesseract/blob/main/README.md>

==================== END FILE: Tesseract-OCR\doc\README.md ====================


==================== START FILE: tools\inventory.py ====================
import os
import datetime
from pathlib import Path

# ==============================================================================
#   DOCREFINE PRO - PROJECT INVENTORY TOOL
#   Run this to generate 'project_inventory.txt'
# ==============================================================================

SKIP_DIRS = {'.git', '__pycache__', 'venv', 'env', '.idea', '.vscode'}
OUTPUT_FILE = "project_inventory.txt"

def get_size_str(size_bytes):
    if size_bytes < 1024: return f"{size_bytes} B"
    elif size_bytes < 1024**2: return f"{size_bytes/1024:.2f} KB"
    elif size_bytes < 1024**3: return f"{size_bytes/(1024**2):.2f} MB"
    else: return f"{size_bytes/(1024**3):.2f} GB"

def run_inventory():
    root_dir = Path.cwd()
    print(f"Scanning: {root_dir}")
    print("This may take a moment...")

    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write(f"PROJECT INVENTORY SCAN\n")
        f.write(f"Root: {root_dir}\n")
        f.write(f"Date: {datetime.datetime.now()}\n")
        f.write("="*80 + "\n\n")

        total_size = 0
        file_count = 0

        for root, dirs, files in os.walk(root_dir):
            # Filter excluded directories in-place
            dirs[:] = [d for d in dirs if d not in SKIP_DIRS]
            
            level = root.replace(str(root_dir), '').count(os.sep)
            indent = ' ' * 4 * (level)
            rel_path = os.path.relpath(root, root_dir)
            
            if rel_path != ".":
                f.write(f"{indent}[{os.path.basename(root)}/]\n")
            
            subindent = ' ' * 4 * (level + 1)
            for fname in files:
                fpath = Path(root) / fname
                try:
                    size = fpath.stat().st_size
                    total_size += size
                    file_count += 1
                    f.write(f"{subindent}{fname}  ({get_size_str(size)})\n")
                except Exception as e:
                    f.write(f"{subindent}{fname}  [ERROR reading file]\n")

        f.write("\n" + "="*80 + "\n")
        f.write(f"TOTAL FILES: {file_count}\n")
        f.write(f"TOTAL SIZE:  {get_size_str(total_size)}\n")

    print(f"‚úÖ Inventory saved to {OUTPUT_FILE}")

if __name__ == "__main__":
    run_inventory()
==================== END FILE: tools\inventory.py ====================

